   1               		.file	"Caterina.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.FetchNextCommandByte,"ax",@progbits
  12               	FetchNextCommandByte:
  13               	.LFB114:
  14               		.file 1 "Caterina.c"
   1:Caterina.c    **** /*
   2:Caterina.c    ****              LUFA Library
   3:Caterina.c    ****      Copyright (C) Dean Camera, 2011.
   4:Caterina.c    **** 
   5:Caterina.c    ****   dean [at] fourwalledcubicle [dot] com
   6:Caterina.c    ****            www.lufa-lib.org
   7:Caterina.c    **** */
   8:Caterina.c    **** 
   9:Caterina.c    **** /*
  10:Caterina.c    ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:Caterina.c    **** 
  12:Caterina.c    ****   Permission to use, copy, modify, distribute, and sell this
  13:Caterina.c    ****   software and its documentation for any purpose is hereby granted
  14:Caterina.c    ****   without fee, provided that the above copyright notice appear in
  15:Caterina.c    ****   all copies and that both that the copyright notice and this
  16:Caterina.c    ****   permission notice and warranty disclaimer appear in supporting
  17:Caterina.c    ****   documentation, and that the name of the author not be used in
  18:Caterina.c    ****   advertising or publicity pertaining to distribution of the
  19:Caterina.c    ****   software without specific, written prior permission.
  20:Caterina.c    **** 
  21:Caterina.c    ****   The author disclaim all warranties with regard to this
  22:Caterina.c    ****   software, including all implied warranties of merchantability
  23:Caterina.c    ****   and fitness.  In no event shall the author be liable for any
  24:Caterina.c    ****   special, indirect or consequential damages or any damages
  25:Caterina.c    ****   whatsoever resulting from loss of use, data or profits, whether
  26:Caterina.c    ****   in an action of contract, negligence or other tortious action,
  27:Caterina.c    ****   arising out of or in connection with the use or performance of
  28:Caterina.c    ****   this software.
  29:Caterina.c    **** */
  30:Caterina.c    **** 
  31:Caterina.c    **** /*
  32:Caterina.c    **** Copyright (c) 2014 Pololu Corporation.  For more information, see
  33:Caterina.c    **** 
  34:Caterina.c    **** 
  35:Caterina.c    **** http://www.pololu.com/
  36:Caterina.c    **** http://forum.pololu.com/
  37:Caterina.c    **** 
  38:Caterina.c    **** Permission is hereby granted, free of charge, to any person
  39:Caterina.c    **** obtaining a copy of this software and associated documentation
  40:Caterina.c    **** files (the "Software"), to deal in the Software without
  41:Caterina.c    **** restriction, including without limitation the rights to use,
  42:Caterina.c    **** copy, modify, merge, publish, distribute, sublicense, and/or sell
  43:Caterina.c    **** copies of the Software, and to permit persons to whom the
  44:Caterina.c    **** Software is furnished to do so, subject to the following
  45:Caterina.c    **** conditions:
  46:Caterina.c    **** 
  47:Caterina.c    **** The above copyright notice and this permission notice shall be
  48:Caterina.c    **** included in all copies or substantial portions of the Software.
  49:Caterina.c    **** 
  50:Caterina.c    **** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  51:Caterina.c    **** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
  52:Caterina.c    **** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  53:Caterina.c    **** NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  54:Caterina.c    **** HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
  55:Caterina.c    **** WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  56:Caterina.c    **** FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  57:Caterina.c    **** OTHER DEALINGS IN THE SOFTWARE.
  58:Caterina.c    **** */
  59:Caterina.c    **** 
  60:Caterina.c    **** /*
  61:Caterina.c    **** File modified by Jaap de Dood to remain in Bootloader while 3DoT power switch is in "Program" Posit
  62:Caterina.c    **** Current limit is set using TWI.
  63:Caterina.c    **** */
  64:Caterina.c    **** 
  65:Caterina.c    **** /** \file
  66:Caterina.c    ****  *
  67:Caterina.c    ****  *  Main source file for the CDC class bootloader. This file contains the complete bootloader logic
  68:Caterina.c    ****  */
  69:Caterina.c    **** 
  70:Caterina.c    **** #define  INCLUDE_FROM_CATERINA_C
  71:Caterina.c    **** #include "Caterina.h"
  72:Caterina.c    **** #include <util/delay.h> // for _delay_ms()
  73:Caterina.c    **** 
  74:Caterina.c    **** /** Contains the current baud rate and other settings of the first virtual serial port. This must b
  75:Caterina.c    ****  *  operating systems will not open the port unless the settings can be set successfully.
  76:Caterina.c    ****  */
  77:Caterina.c    **** static CDC_LineEncoding_t LineEncoding = { .BaudRateBPS = 0,
  78:Caterina.c    ****                                            .CharFormat  = CDC_LINEENCODING_OneStopBit,
  79:Caterina.c    ****                                            .ParityType  = CDC_PARITY_None,
  80:Caterina.c    ****                                            .DataBits    = 8                            };
  81:Caterina.c    **** 
  82:Caterina.c    **** /** Current address counter. This stores the current address of the FLASH or EEPROM as set by the h
  83:Caterina.c    ****  *  and is used when reading or writing to the AVRs memory (either FLASH or EEPROM depending on the
  84:Caterina.c    ****  *  command.)
  85:Caterina.c    ****  */
  86:Caterina.c    **** static uint32_t CurrAddress;
  87:Caterina.c    **** 
  88:Caterina.c    **** /** Flag to indicate if the bootloader should be running, or should exit and allow the application 
  89:Caterina.c    ****  *  via a watchdog reset. When cleared the bootloader will exit, starting the watchdog and entering
  90:Caterina.c    ****  *  loop until the AVR restarts and the application runs.
  91:Caterina.c    ****  */
  92:Caterina.c    **** //static bool RunBootloader = true;
  93:Caterina.c    **** 
  94:Caterina.c    **** /* Pulse generation counters to keep track of the time remaining for each pulse type */
  95:Caterina.c    **** #define TX_RX_LED_PULSE_PERIOD 100
  96:Caterina.c    **** uint16_t TxLEDPulse = 0; // time remaining for Tx LED pulse
  97:Caterina.c    **** uint16_t RxLEDPulse = 0; // time remaining for Rx LED pulse
  98:Caterina.c    **** 
  99:Caterina.c    **** /* Bootloader timeout timer */
 100:Caterina.c    **** #define TIMEOUT_PERIOD	488
 101:Caterina.c    **** uint16_t Timeout = 0;
 102:Caterina.c    **** 
 103:Caterina.c    **** /* MCP4017 current limit R = 100k(POT_STEPS/128), see TPS2553 datasheet for R/Ilim graph */
 104:Caterina.c    **** #define POT_STEPS 0x00 
 105:Caterina.c    **** #define SLA_W 0x5E // SLA = 0x2F, MSB transmitted first, W = 0
 106:Caterina.c    **** 
 107:Caterina.c    **** void StartSketch(void)
 108:Caterina.c    **** {
 109:Caterina.c    ****     cli();
 110:Caterina.c    **** 
 111:Caterina.c    ****     /* Undo TIMER1 setup and clear the count before running the sketch */
 112:Caterina.c    ****     TIMSK1 = 0;
 113:Caterina.c    ****     TCCR1B = 0;
 114:Caterina.c    ****     TCNT1H = 0;		// 16-bit write to TCNT1 requires high byte be written first
 115:Caterina.c    ****     TCNT1L = 0;
 116:Caterina.c    **** 
 117:Caterina.c    ****     /* Relocate the interrupt vector table to the application section */
 118:Caterina.c    ****     MCUCR = (1 << IVCE);
 119:Caterina.c    ****     MCUCR = 0;
 120:Caterina.c    **** 
 121:Caterina.c    ****     L_LED_OFF();
 122:Caterina.c    ****     TX_LED_OFF();
 123:Caterina.c    ****     RX_LED_OFF();
 124:Caterina.c    **** 
 125:Caterina.c    ****     /* jump to beginning of application space */
 126:Caterina.c    ****     __asm__ volatile("jmp 0x0000");
 127:Caterina.c    **** }
 128:Caterina.c    **** 
 129:Caterina.c    **** void TWIInit(void)
 130:Caterina.c    **** {
 131:Caterina.c    ****     /* Set SCL frequency to ~200kHz */
 132:Caterina.c    ****     TWSR = 0x00;
 133:Caterina.c    ****     TWBR = 0x0C;
 134:Caterina.c    **** 
 135:Caterina.c    ****     /* Enable TWI */
 136:Caterina.c    ****     TWCR = (1<<TWEN);
 137:Caterina.c    **** }
 138:Caterina.c    **** 
 139:Caterina.c    **** void TWIStart(void)
 140:Caterina.c    **** {
 141:Caterina.c    ****     /* Send START condition */
 142:Caterina.c    ****     TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
 143:Caterina.c    ****     /* Wait for TWINT Flag set. This indicates that the START condition has been transmitted */
 144:Caterina.c    ****     while(!(TWCR & (1<<TWINT)));
 145:Caterina.c    **** }
 146:Caterina.c    **** 
 147:Caterina.c    **** void TWIStop(void)
 148:Caterina.c    **** {
 149:Caterina.c    ****     TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWSTO);
 150:Caterina.c    **** }
 151:Caterina.c    **** 
 152:Caterina.c    **** void TWIWrite(uint8_t u8data)
 153:Caterina.c    **** {
 154:Caterina.c    ****     /* Load data into TWDR Register. Clear TWINT bit in TWCR to start transmission */
 155:Caterina.c    ****     TWDR = u8data;
 156:Caterina.c    ****     TWCR = (1<<TWINT)|(1<<TWEN);
 157:Caterina.c    ****     /* Wait for TWINT Flag set. This indicates that the data has been transmitted, and ACK/NACK has
 158:Caterina.c    ****     while(!(TWCR & (1<<TWINT)));
 159:Caterina.c    **** }
 160:Caterina.c    **** 
 161:Caterina.c    **** void SetupCurrentLimit(void)
 162:Caterina.c    **** {
 163:Caterina.c    ****     /* Initialize I2C */
 164:Caterina.c    ****     TWIStart();
 165:Caterina.c    **** 
 166:Caterina.c    ****     /* Write slave address (MCP4017) + Write bit */
 167:Caterina.c    ****     TWIWrite(SLA_W);
 168:Caterina.c    **** 
 169:Caterina.c    ****     /* Write resistance value */
 170:Caterina.c    ****     TWIWrite(POT_STEPS);
 171:Caterina.c    **** 
 172:Caterina.c    ****     TWIStop();
 173:Caterina.c    **** }
 174:Caterina.c    **** 
 175:Caterina.c    **** uint16_t ReadBatteryVoltage(void)
 176:Caterina.c    **** {
 177:Caterina.c    ****     /* Set PINF0 to Input */
 178:Caterina.c    ****     DDRF &= ~(1 << PF0);
 179:Caterina.c    ****     PORTF |= (1 << PF0);
 180:Caterina.c    **** 
 181:Caterina.c    ****     uint8_t low, high;
 182:Caterina.c    **** 
 183:Caterina.c    ****     /* Set the analog reference to Internal 2.56V */
 184:Caterina.c    ****     ADMUX |= (1 << REFS1) | (1 << REFS0);
 185:Caterina.c    ****     /* Set ADC Mux to ADC0 */
 186:Caterina.c    ****     ADMUX &= ~0b00011111;
 187:Caterina.c    ****     _delay_ms(1); // Just to be safe
 188:Caterina.c    **** 
 189:Caterina.c    ****     /* Start Conversion */
 190:Caterina.c    ****     ADCSRA |= (1<<ADSC);
 191:Caterina.c    **** 
 192:Caterina.c    ****     /* Wait for Conversion to finish. ADSC is cleared when the conversion finishes */
 193:Caterina.c    ****     while (bit_is_set(ADCSRA, ADSC));
 194:Caterina.c    **** 
 195:Caterina.c    ****     /* we read ADCL first; doing so locks both ADCL
 196:Caterina.c    ****      * and ADCH until ADCH is read. reading ADCL second would
 197:Caterina.c    ****      * cause the results of each conversion to be discarded,
 198:Caterina.c    ****      * as ADCL and ADCH would be locked when it completed. */
 199:Caterina.c    ****     low = ADCL;
 200:Caterina.c    ****     high = ADCH;
 201:Caterina.c    **** 
 202:Caterina.c    ****     // combine the two bytes
 203:Caterina.c    ****     return (high << 8) | low;
 204:Caterina.c    **** }
 205:Caterina.c    **** 
 206:Caterina.c    **** void AlertFatalError(void)
 207:Caterina.c    **** {
 208:Caterina.c    ****     /* Blink like mad */
 209:Caterina.c    ****     while(1)
 210:Caterina.c    ****     {
 211:Caterina.c    ****         TX_LED_ON();
 212:Caterina.c    ****         RX_LED_ON();
 213:Caterina.c    ****         L_LED_ON();
 214:Caterina.c    ****         _delay_ms(100);
 215:Caterina.c    ****         TX_LED_OFF();
 216:Caterina.c    ****         RX_LED_OFF();
 217:Caterina.c    ****         L_LED_OFF();
 218:Caterina.c    ****         _delay_ms(100);
 219:Caterina.c    ****     }
 220:Caterina.c    ****     /* When Buzzer is implemented in hardware, buzzer will beep here */
 221:Caterina.c    **** }
 222:Caterina.c    **** 
 223:Caterina.c    **** /*	Breathing animation on L LED indicates bootloader is running */
 224:Caterina.c    **** uint16_t LLEDPulse;
 225:Caterina.c    **** void LEDPulse(void)
 226:Caterina.c    **** {
 227:Caterina.c    ****     LLEDPulse++;
 228:Caterina.c    ****     uint8_t p = LLEDPulse >> 8;
 229:Caterina.c    ****     if (p > 127)
 230:Caterina.c    ****         p = 254-p;
 231:Caterina.c    ****     p += p;
 232:Caterina.c    ****     if (((uint8_t)LLEDPulse) > p)
 233:Caterina.c    ****         L_LED_OFF();
 234:Caterina.c    ****     else
 235:Caterina.c    ****         L_LED_ON();
 236:Caterina.c    **** }
 237:Caterina.c    **** 
 238:Caterina.c    **** /** Main program entry point. This routine configures the hardware required by the bootloader, then
 239:Caterina.c    ****  *  runs the bootloader processing routine until it times out or is instructed to exit.
 240:Caterina.c    ****  */
 241:Caterina.c    **** int main(void)
 242:Caterina.c    **** {
 243:Caterina.c    ****     /* Clear all reset flags - some may be used by sketch */
 244:Caterina.c    ****     MCUSR = 0;
 245:Caterina.c    ****     /* Watchdog may be configured with a 15 ms period so must disable it before going any further *
 246:Caterina.c    ****     wdt_disable();
 247:Caterina.c    **** 
 248:Caterina.c    ****     /* Initialize BootMode switch pin*/
 249:Caterina.c    ****     BootMode_Init();
 250:Caterina.c    ****     _delay_ms(10);    // allow time for caps to charge
 251:Caterina.c    **** 
 252:Caterina.c    ****     if ((isBootMode() || (pgm_read_word(0) == 0xFFFF)))
 253:Caterina.c    ****     {
 254:Caterina.c    ****         // Switch is in Boot mode position or there is no sketch
 255:Caterina.c    **** 
 256:Caterina.c    ****         /* Setup hardware required for the bootloader */
 257:Caterina.c    ****         SetupHardware();
 258:Caterina.c    **** 
 259:Caterina.c    ****         /* Enable global interrupts so that the USB stack can function */
 260:Caterina.c    ****         sei();
 261:Caterina.c    **** 
 262:Caterina.c    ****         while(isBootMode()){
 263:Caterina.c    ****             CDC_Task();
 264:Caterina.c    ****             USB_USBTask();
 265:Caterina.c    **** 
 266:Caterina.c    ****             LEDPulse();
 267:Caterina.c    ****         }
 268:Caterina.c    ****     }
 269:Caterina.c    ****     /* Disconnect from the host - USB interface will be reset later along with the AVR */
 270:Caterina.c    ****     USB_Detach();
 271:Caterina.c    **** 
 272:Caterina.c    ****     SetupCurrentLimit();
 273:Caterina.c    **** 
 274:Caterina.c    ****     /* Check battery voltage is above 3.3V   
 275:Caterina.c    ****     if(ReadBatteryVoltage() < 740) {
 276:Caterina.c    ****         AlertFatalError();
 277:Caterina.c    ****     }*/
 278:Caterina.c    **** 
 279:Caterina.c    ****     /* Jump to beginning of application space to run the sketch - do not reset */
 280:Caterina.c    ****     StartSketch();
 281:Caterina.c    **** }
 282:Caterina.c    **** 
 283:Caterina.c    **** /** Configures all hardware re
 284:Caterina.c    ****     quired for the bootloader. */
 285:Caterina.c    **** void SetupHardware(void)
 286:Caterina.c    **** {
 287:Caterina.c    ****     /* Disable clock division */
 288:Caterina.c    ****     //clock_prescale_set(clock_div_1); // redundant
 289:Caterina.c    ****     CPU_PRESCALE(0);
 290:Caterina.c    **** 
 291:Caterina.c    ****     /* Relocate the interrupt vector table to the bootloader section */
 292:Caterina.c    ****     MCUCR = (1 << IVCE);
 293:Caterina.c    ****     MCUCR = (1 << IVSEL);
 294:Caterina.c    **** 
 295:Caterina.c    ****     LED_SETUP();
 296:Caterina.c    ****     L_LED_OFF();
 297:Caterina.c    ****     TX_LED_OFF();
 298:Caterina.c    ****     RX_LED_OFF();
 299:Caterina.c    **** 
 300:Caterina.c    ****     /* Initialize TIMER1 to handle bootloader timeout and LED tasks.
 301:Caterina.c    ****      * With 16 MHz clock and 1/64 prescaler, timer 1 is clocked at 250 kHz
 302:Caterina.c    ****      * Our chosen compare match generates an interrupt every 1 ms.
 303:Caterina.c    ****      * This interrupt is disabled selectively when doing memory reading, erasing,
 304:Caterina.c    ****      * or writing since SPM has tight timing requirements.
 305:Caterina.c    ****      */
 306:Caterina.c    ****     OCR1AH = 0;
 307:Caterina.c    ****     OCR1AL = 250;
 308:Caterina.c    ****     TIMSK1 = (1 << OCIE1A);					// enable timer 1 output compare A match interrupt
 309:Caterina.c    ****     TCCR1B = ((1 << CS11) | (1 << CS10));	// 1/64 prescaler on timer 1 input
 310:Caterina.c    **** 
 311:Caterina.c    ****     /* Initialize USB Subsystem */
 312:Caterina.c    ****     USB_Init();
 313:Caterina.c    **** }
 314:Caterina.c    **** 
 315:Caterina.c    **** //uint16_t ctr = 0;
 316:Caterina.c    **** ISR(TIMER1_COMPA_vect, ISR_BLOCK)
 317:Caterina.c    **** {
 318:Caterina.c    ****     /* Reset counter */
 319:Caterina.c    ****     TCNT1H = 0;
 320:Caterina.c    ****     TCNT1L = 0;
 321:Caterina.c    **** 
 322:Caterina.c    ****     /* Check whether the TX or RX LED one-shot period has elapsed.  if so, turn off the LED */
 323:Caterina.c    ****     if (TxLEDPulse && !(--TxLEDPulse))
 324:Caterina.c    ****         TX_LED_OFF();
 325:Caterina.c    ****     if (RxLEDPulse && !(--RxLEDPulse))
 326:Caterina.c    ****         RX_LED_OFF();
 327:Caterina.c    **** 
 328:Caterina.c    ****     if (pgm_read_word(0) != 0xFFFF)
 329:Caterina.c    ****         Timeout++;
 330:Caterina.c    **** }
 331:Caterina.c    **** 
 332:Caterina.c    **** /** Event handler for the USB_ConfigurationChanged event. This configures the device's endpoints re
 333:Caterina.c    ****  *  to relay data to and from the attached USB host.
 334:Caterina.c    ****  */
 335:Caterina.c    **** void EVENT_USB_Device_ConfigurationChanged(void)
 336:Caterina.c    **** {
 337:Caterina.c    ****     /* Setup CDC Notification, Rx and Tx Endpoints */
 338:Caterina.c    ****     Endpoint_ConfigureEndpoint(CDC_NOTIFICATION_EPNUM, EP_TYPE_INTERRUPT,
 339:Caterina.c    ****                                ENDPOINT_DIR_IN, CDC_NOTIFICATION_EPSIZE,
 340:Caterina.c    ****                                ENDPOINT_BANK_SINGLE);
 341:Caterina.c    **** 
 342:Caterina.c    ****     Endpoint_ConfigureEndpoint(CDC_TX_EPNUM, EP_TYPE_BULK,
 343:Caterina.c    ****                                ENDPOINT_DIR_IN, CDC_TXRX_EPSIZE,
 344:Caterina.c    ****                                ENDPOINT_BANK_SINGLE);
 345:Caterina.c    **** 
 346:Caterina.c    ****     Endpoint_ConfigureEndpoint(CDC_RX_EPNUM, EP_TYPE_BULK,
 347:Caterina.c    ****                                ENDPOINT_DIR_OUT, CDC_TXRX_EPSIZE,
 348:Caterina.c    ****                                ENDPOINT_BANK_SINGLE);
 349:Caterina.c    **** }
 350:Caterina.c    **** 
 351:Caterina.c    **** /** Event handler for the USB_ControlRequest event. This is used to catch and process control reque
 352:Caterina.c    ****  *  the device from the USB host before passing along unhandled control requests to the library for
 353:Caterina.c    ****  *  internally.
 354:Caterina.c    ****  */
 355:Caterina.c    **** void EVENT_USB_Device_ControlRequest(void)
 356:Caterina.c    **** {
 357:Caterina.c    ****     /* Ignore any requests that aren't directed to the CDC interface */
 358:Caterina.c    ****     if ((USB_ControlRequest.bmRequestType & (CONTROL_REQTYPE_TYPE | CONTROL_REQTYPE_RECIPIENT)) !=
 359:Caterina.c    ****         (REQTYPE_CLASS | REQREC_INTERFACE))
 360:Caterina.c    ****     {
 361:Caterina.c    ****         return;
 362:Caterina.c    ****     }
 363:Caterina.c    **** 
 364:Caterina.c    ****     /* Process CDC specific control requests */
 365:Caterina.c    ****     switch (USB_ControlRequest.bRequest)
 366:Caterina.c    ****     {
 367:Caterina.c    ****         case CDC_REQ_GetLineEncoding:
 368:Caterina.c    ****             if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_I
 369:Caterina.c    ****             {
 370:Caterina.c    ****                 Endpoint_ClearSETUP();
 371:Caterina.c    **** 
 372:Caterina.c    ****                 /* Write the line coding data to the control endpoint */
 373:Caterina.c    ****                 Endpoint_Write_Control_Stream_LE(&LineEncoding, sizeof(CDC_LineEncoding_t));
 374:Caterina.c    ****                 Endpoint_ClearOUT();
 375:Caterina.c    ****             }
 376:Caterina.c    **** 
 377:Caterina.c    ****             break;
 378:Caterina.c    ****         case CDC_REQ_SetLineEncoding:
 379:Caterina.c    ****             if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_I
 380:Caterina.c    ****             {
 381:Caterina.c    ****                 Endpoint_ClearSETUP();
 382:Caterina.c    **** 
 383:Caterina.c    ****                 /* Read the line coding data in from the host into the global struct */
 384:Caterina.c    ****                 Endpoint_Read_Control_Stream_LE(&LineEncoding, sizeof(CDC_LineEncoding_t));
 385:Caterina.c    ****                 Endpoint_ClearIN();
 386:Caterina.c    ****             }
 387:Caterina.c    **** 
 388:Caterina.c    ****             break;
 389:Caterina.c    ****     }
 390:Caterina.c    **** }
 391:Caterina.c    **** 
 392:Caterina.c    **** #if !defined(NO_BLOCK_SUPPORT)
 393:Caterina.c    **** /** Reads or writes a block of EEPROM or FLASH memory to or from the appropriate CDC data endpoint,
 394:Caterina.c    ****  *  on the AVR910 protocol command issued.
 395:Caterina.c    ****  *
 396:Caterina.c    ****  *  \param[in] Command  Single character AVR910 protocol command indicating what memory operation t
 397:Caterina.c    ****  */
 398:Caterina.c    **** static void ReadWriteMemoryBlock(const uint8_t Command)
 399:Caterina.c    **** {
 400:Caterina.c    ****     uint16_t BlockSize;
 401:Caterina.c    ****     char     MemoryType;
 402:Caterina.c    **** 
 403:Caterina.c    ****     bool     HighByte = false;
 404:Caterina.c    ****     uint8_t  LowByte  = 0;
 405:Caterina.c    **** 
 406:Caterina.c    ****     BlockSize  = (FetchNextCommandByte() << 8);
 407:Caterina.c    ****     BlockSize |=  FetchNextCommandByte();
 408:Caterina.c    **** 
 409:Caterina.c    ****     MemoryType =  FetchNextCommandByte();
 410:Caterina.c    **** 
 411:Caterina.c    ****     if ((MemoryType != 'E') && (MemoryType != 'F'))
 412:Caterina.c    ****     {
 413:Caterina.c    ****         /* Send error byte back to the host */
 414:Caterina.c    ****         WriteNextResponseByte('?');
 415:Caterina.c    **** 
 416:Caterina.c    ****         return;
 417:Caterina.c    ****     }
 418:Caterina.c    **** 
 419:Caterina.c    ****     /* Disable timer 1 interrupt - can't afford to process nonessential interrupts
 420:Caterina.c    ****      * while doing SPM tasks */
 421:Caterina.c    ****     TIMSK1 = 0;
 422:Caterina.c    **** 
 423:Caterina.c    ****     /* Check if command is to read memory */
 424:Caterina.c    ****     if (Command == 'g')
 425:Caterina.c    ****     {
 426:Caterina.c    ****         /* Re-enable RWW section */
 427:Caterina.c    ****         boot_rww_enable();
 428:Caterina.c    **** 
 429:Caterina.c    ****         while (BlockSize--)
 430:Caterina.c    ****         {
 431:Caterina.c    ****             if (MemoryType == 'F')
 432:Caterina.c    ****             {
 433:Caterina.c    ****                 /* Read the next FLASH byte from the current FLASH page */
 434:Caterina.c    ****                 #if (FLASHEND > 0xFFFF)
 435:Caterina.c    ****                 WriteNextResponseByte(pgm_read_byte_far(CurrAddress | HighByte));
 436:Caterina.c    ****                 #else
 437:Caterina.c    ****                 WriteNextResponseByte(pgm_read_byte(CurrAddress | HighByte));
 438:Caterina.c    ****                 #endif
 439:Caterina.c    **** 
 440:Caterina.c    ****                 /* If both bytes in current word have been read, increment the address counter */
 441:Caterina.c    ****                 if (HighByte)
 442:Caterina.c    ****                   CurrAddress += 2;
 443:Caterina.c    **** 
 444:Caterina.c    ****                 HighByte = !HighByte;
 445:Caterina.c    ****             }
 446:Caterina.c    ****             else
 447:Caterina.c    ****             {
 448:Caterina.c    ****                 /* Read the next EEPROM byte into the endpoint */
 449:Caterina.c    ****                 WriteNextResponseByte(eeprom_read_byte((uint8_t*)(intptr_t)(CurrAddress >> 1)));
 450:Caterina.c    **** 
 451:Caterina.c    ****                 /* Increment the address counter after use */
 452:Caterina.c    ****                 CurrAddress += 2;
 453:Caterina.c    ****             }
 454:Caterina.c    ****         }
 455:Caterina.c    ****     }
 456:Caterina.c    ****     else
 457:Caterina.c    ****     {
 458:Caterina.c    ****         uint32_t PageStartAddress = CurrAddress;
 459:Caterina.c    **** 
 460:Caterina.c    ****         if (MemoryType == 'F')
 461:Caterina.c    ****         {
 462:Caterina.c    ****             boot_page_erase(PageStartAddress);
 463:Caterina.c    ****             boot_spm_busy_wait();
 464:Caterina.c    ****         }
 465:Caterina.c    **** 
 466:Caterina.c    ****         while (BlockSize--)
 467:Caterina.c    ****         {
 468:Caterina.c    ****             if (MemoryType == 'F')
 469:Caterina.c    ****             {
 470:Caterina.c    ****                 /* If both bytes in current word have been written, increment the address counter *
 471:Caterina.c    ****                 if (HighByte)
 472:Caterina.c    ****                 {
 473:Caterina.c    ****                     /* Write the next FLASH word to the current FLASH page */
 474:Caterina.c    ****                     boot_page_fill(CurrAddress, ((FetchNextCommandByte() << 8) | LowByte));
 475:Caterina.c    **** 
 476:Caterina.c    ****                     /* Increment the address counter after use */
 477:Caterina.c    ****                     CurrAddress += 2;
 478:Caterina.c    ****                 }
 479:Caterina.c    ****                 else
 480:Caterina.c    ****                 {
 481:Caterina.c    ****                     LowByte = FetchNextCommandByte();
 482:Caterina.c    ****                 }
 483:Caterina.c    **** 
 484:Caterina.c    ****                 HighByte = !HighByte;
 485:Caterina.c    ****             }
 486:Caterina.c    ****             else
 487:Caterina.c    ****             {
 488:Caterina.c    ****                 /* Write the next EEPROM byte from the endpoint */
 489:Caterina.c    ****                 eeprom_write_byte((uint8_t*)((intptr_t)(CurrAddress >> 1)), FetchNextCommandByte())
 490:Caterina.c    **** 
 491:Caterina.c    ****                 /* Increment the address counter after use */
 492:Caterina.c    ****                 CurrAddress += 2;
 493:Caterina.c    ****             }
 494:Caterina.c    ****         }
 495:Caterina.c    **** 
 496:Caterina.c    ****         /* If in FLASH programming mode, commit the page after writing */
 497:Caterina.c    ****         if (MemoryType == 'F')
 498:Caterina.c    ****         {
 499:Caterina.c    ****             /* Commit the flash page to memory */
 500:Caterina.c    ****             boot_page_write(PageStartAddress);
 501:Caterina.c    **** 
 502:Caterina.c    ****             /* Wait until write operation has completed */
 503:Caterina.c    ****             boot_spm_busy_wait();
 504:Caterina.c    ****         }
 505:Caterina.c    **** 
 506:Caterina.c    ****         /* Send response byte back to the host */
 507:Caterina.c    ****         WriteNextResponseByte('\r');
 508:Caterina.c    ****     }
 509:Caterina.c    **** 
 510:Caterina.c    ****     /* Re-enable timer 1 interrupt disabled earlier in this routine */
 511:Caterina.c    ****     TIMSK1 = (1 << OCIE1A);
 512:Caterina.c    **** }
 513:Caterina.c    **** #endif
 514:Caterina.c    **** 
 515:Caterina.c    **** /** Retrieves the next byte from the host in the CDC data OUT endpoint, and clears the endpoint ban
 516:Caterina.c    ****  *  to allow reception of the next data packet from the host.
 517:Caterina.c    ****  *
 518:Caterina.c    ****  *  \return Next received byte from the host in the CDC data OUT endpoint
 519:Caterina.c    ****  */
 520:Caterina.c    **** static uint8_t FetchNextCommandByte(void)
 521:Caterina.c    **** {
  15               		.loc 1 521 1 view -0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
 522:Caterina.c    ****     /* Select the OUT endpoint so that the next data byte can be read */
 523:Caterina.c    ****     Endpoint_SelectEndpoint(CDC_RX_EPNUM);
  21               		.loc 1 523 5 view .LVU1
  22               	.LVL0:
  23               	.LBB86:
  24               	.LBI86:
  25               		.file 2 "../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h"
   1:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** /*
   2:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****              LUFA Library
   3:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****      Copyright (C) Dean Camera, 2011.
   4:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
   5:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   dean [at] fourwalledcubicle [dot] com
   6:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****            www.lufa-lib.org
   7:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** */
   8:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
   9:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** /*
  10:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  12:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   Permission to use, copy, modify, distribute, and sell this
  13:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   software and its documentation for any purpose is hereby granted
  14:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   without fee, provided that the above copyright notice appear in
  15:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   all copies and that both that the copyright notice and this
  16:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   permission notice and warranty disclaimer appear in supporting
  17:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   documentation, and that the name of the author not be used in
  18:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   advertising or publicity pertaining to distribution of the
  19:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   software without specific, written prior permission.
  20:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  21:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   The author disclaim all warranties with regard to this
  22:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   software, including all implied warranties of merchantability
  23:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   and fitness.  In no event shall the author be liable for any
  24:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   special, indirect or consequential damages or any damages
  25:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   whatsoever resulting from loss of use, data or profits, whether
  26:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   in an action of contract, negligence or other tortious action,
  27:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   arising out of or in connection with the use or performance of
  28:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****   this software.
  29:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** */
  30:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  31:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** /** \file
  32:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  \brief USB Endpoint definitions for the AVR8 microcontrollers.
  33:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  \copydetails Group_EndpointManagement_AVR8
  34:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *
  35:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  \note This file should not be included directly. It is automatically included as needed by the 
  36:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *        dispatch header located in LUFA/Drivers/USB/USB.h.
  37:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  */
  38:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  39:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** /** \ingroup Group_EndpointRW
  40:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  \defgroup Group_EndpointRW_AVR8 Endpoint Data Reading and Writing (AVR8)
  41:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  \brief Endpoint data read/write definitions for the Atmel AVR8 architecture.
  42:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *
  43:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  Functions, macros, variables, enums and types related to data reading and writing from and to e
  44:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  */
  45:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  46:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** /** \ingroup Group_EndpointPrimitiveRW
  47:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  \defgroup Group_EndpointPrimitiveRW_AVR8 Read/Write of Primitive Data Types (AVR8)
  48:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  \brief Endpoint primitive read/write definitions for the Atmel AVR8 architecture.
  49:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *
  50:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  Functions, macros, variables, enums and types related to data reading and writing of primitive 
  51:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  from and to endpoints.
  52:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  */
  53:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  54:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** /** \ingroup Group_EndpointPacketManagement
  55:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  \defgroup Group_EndpointPacketManagement_AVR8 Endpoint Packet Management (AVR8)
  56:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  \brief Endpoint packet management definitions for the Atmel AVR8 architecture.
  57:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *
  58:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  Functions, macros, variables, enums and types related to packet management of endpoints.
  59:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  */
  60:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  61:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** /** \ingroup Group_EndpointManagement
  62:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  \defgroup Group_EndpointManagement_AVR8 Endpoint Management (AVR8)
  63:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  \brief Endpoint management definitions for the Atmel AVR8 architecture.
  64:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *
  65:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  Functions, macros and enums related to endpoint management when in USB Device mode. This
  66:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  module contains the endpoint management macros, as well as endpoint interrupt and data
  67:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  send/receive functions for various data types.
  68:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *
  69:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  *  @{
  70:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h ****  */
  71:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  72:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** #ifndef __ENDPOINT_AVR8_H__
  73:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** #define __ENDPOINT_AVR8_H__
  74:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  75:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 	/* Includes: */
  76:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		#include "../../../../Common/Common.h"
  77:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		#include "../USBTask.h"
  78:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		#include "../USBInterrupt.h"
  79:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  80:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 	/* Enable C linkage for C++ Compilers: */
  81:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		#if defined(__cplusplus)
  82:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			extern "C" {
  83:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		#endif
  84:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  85:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 	/* Preprocessor Checks: */
  86:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		#if !defined(__INCLUDE_FROM_USB_DRIVER)
  87:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#error Do not include this file directly. Include LUFA/Drivers/USB/USB.h instead.
  88:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		#endif
  89:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  90:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 	/* Private Interface - For use in library only: */
  91:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 	#if !defined(__DOXYGEN__)
  92:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		/* Macros: */
  93:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#define _ENDPOINT_GET_MAXSIZE(EPIndex)         _ENDPOINT_GET_MAXSIZE2(ENDPOINT_DETAILS_EP ## EPI
  94:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#define _ENDPOINT_GET_MAXSIZE2(EPDetails)      _ENDPOINT_GET_MAXSIZE3(EPDetails)
  95:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#define _ENDPOINT_GET_MAXSIZE3(MaxSize, Banks) (MaxSize)
  96:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
  97:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#define _ENDPOINT_GET_BANKS(EPIndex)           _ENDPOINT_GET_BANKS2(ENDPOINT_DETAILS_EP ## EPInd
  98:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#define _ENDPOINT_GET_BANKS2(EPDetails)        _ENDPOINT_GET_BANKS3(EPDetails)
  99:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#define _ENDPOINT_GET_BANKS3(MaxSize, Banks)   (Banks)
 100:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 101:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
 102:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_MAXEP             7
 103:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 104:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_EP0               64,  1
 105:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_EP1               256, 2
 106:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_EP2               64,  2
 107:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_EP3               64,  2
 108:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_EP4               64,  2
 109:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_EP5               64,  2
 110:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_EP6               64,  2
 111:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#else
 112:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_MAXEP             5
 113:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 114:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_EP0               64,  1
 115:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_EP1               64,  1
 116:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_EP2               64,  1
 117:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_EP3               64,  2
 118:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_DETAILS_EP4               64,  2
 119:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#endif
 120:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 121:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		/* Inline Functions: */
 122:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT A
 123:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			                                                                       ATTR_ALWAYS_INLINE;
 124:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
 125:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 126:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				uint8_t  MaskVal    = 0;
 127:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				uint16_t CheckBytes = 8;
 128:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 129:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				while (CheckBytes < Bytes)
 130:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				{
 131:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					MaskVal++;
 132:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					CheckBytes <<= 1;
 133:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				}
 134:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 135:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return (MaskVal << EPSIZE0);
 136:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 137:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 138:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		/* Function Prototypes: */
 139:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			void Endpoint_ClearEndpoints(void);
 140:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			bool Endpoint_ConfigureEndpoint_Prv(const uint8_t Number,
 141:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			                                    const uint8_t UECFG0XData,
 142:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			                                    const uint8_t UECFG1XData);
 143:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 144:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 	#endif
 145:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 146:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 	/* Public Interface - May be used in end-application: */
 147:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		/* Macros: */			
 148:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** \name Endpoint Bank Mode Masks */
 149:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			//@{
 150:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Mask for the bank mode selection for the \ref Endpoint_ConfigureEndpoint() macro. This indic
 151:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  that the endpoint should have one single bank, which requires less USB FIFO memory but resul
 152:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  in slower transfers as only one USB device (the AVR or the host) can access the endpoint's
 153:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  bank at the one time.
 154:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 155:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#define ENDPOINT_BANK_SINGLE                    (0 << EPBK0)
 156:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 157:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Mask for the bank mode selection for the \ref Endpoint_ConfigureEndpoint() macro. This indic
 158:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  that the endpoint should have two banks, which requires more USB FIFO memory but results
 159:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  in faster transfers as one USB device (the AVR or the host) can access one bank while the ot
 160:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  accesses the second bank.
 161:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 162:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#define ENDPOINT_BANK_DOUBLE                    (1 << EPBK0)
 163:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			//@}
 164:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 165:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#if (!defined(FIXED_CONTROL_ENDPOINT_SIZE) || defined(__DOXYGEN__))
 166:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				/** Default size of the default control endpoint's bank, until altered by the control endpoint 
 167:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				 *  value in the device descriptor. Not available if the \c FIXED_CONTROL_ENDPOINT_SIZE token i
 168:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				 */
 169:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_CONTROLEP_DEFAULT_SIZE     8
 170:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#endif
 171:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 172:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Retrieves the maximum bank size in bytes of a given endpoint.
 173:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 174:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \note This macro will only work correctly on endpoint indexes that are compile-time constant
 175:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *        defined by the preprocessor.
 176:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 177:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \param[in] EPIndex  Endpoint number, a value between 0 and (\ref ENDPOINT_TOTAL_ENDPOINTS - 
 178:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 179:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#define ENDPOINT_MAX_SIZE(EPIndex)              _ENDPOINT_GET_MAXSIZE(EPIndex)
 180:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 181:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Retrieves the total number of banks supported by the given endpoint.
 182:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 183:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \note This macro will only work correctly on endpoint indexes that are compile-time constant
 184:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *        defined by the preprocessor.
 185:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 186:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \param[in] EPIndex  Endpoint number, a value between 0 and (\ref ENDPOINT_TOTAL_ENDPOINTS - 
 187:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 188:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#define ENDPOINT_BANKS_SUPPORTED(EPIndex)       _ENDPOINT_GET_BANKS(EPIndex)
 189:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 190:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#if !defined(CONTROL_ONLY_DEVICE) || defined(__DOXYGEN__)
 191:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				/** Total number of endpoints (including the default control endpoint at address 0) which may
 192:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				 *  be used in the device. Different USB AVR models support different amounts of endpoints,
 193:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				 *  this value reflects the maximum number of endpoints for the currently selected AVR model.
 194:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				 */
 195:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_TOTAL_ENDPOINTS            ENDPOINT_DETAILS_MAXEP
 196:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#else
 197:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#define ENDPOINT_TOTAL_ENDPOINTS            1
 198:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			#endif
 199:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 200:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		/* Enums: */
 201:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Enum for the possible error return codes of the \ref Endpoint_WaitUntilReady() function.
 202:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 203:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointRW_AVR8
 204:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 205:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			enum Endpoint_WaitUntilReady_ErrorCodes_t
 206:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 207:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				ENDPOINT_READYWAIT_NoError                 = 0, /**< Endpoint is ready for next packet, no erro
 208:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				ENDPOINT_READYWAIT_EndpointStalled         = 1, /**< The endpoint was stalled during the stream
 209:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                                 *   transfer by the host or device.
 210:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                                 */
 211:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				ENDPOINT_READYWAIT_DeviceDisconnected      = 2,	/**< Device was disconnected from the host whil
 212:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                                 *   waiting for the endpoint to become ready.
 213:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                                 */
 214:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				ENDPOINT_READYWAIT_BusSuspended            = 3, /**< The USB bus has been suspended by the host
 215:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                                 *   no USB endpoint traffic can occur until th
 216:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                                 *   has resumed.
 217:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                                 */
 218:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				ENDPOINT_READYWAIT_Timeout                 = 4, /**< The host failed to accept or send the next
 219:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                                 *   within the software timeout period set by 
 220:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                                 *   \ref USB_STREAM_TIMEOUT_MS macro.
 221:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                                 */
 222:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			};
 223:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 224:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 		/* Inline Functions: */
 225:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Configures the specified endpoint number with the given endpoint type, direction, bank size
 226:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  and banking mode. Once configured, the endpoint may be read from or written to, depending
 227:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  on its direction.
 228:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 229:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \param[in] Number     Endpoint number to configure. This must be more than 0 and less than
 230:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *                        \ref ENDPOINT_TOTAL_ENDPOINTS.
 231:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 232:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \param[in] Type       Type of endpoint to configure, a \c EP_TYPE_* mask. Not all endpoint t
 233:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *                        are available on Low Speed USB devices - refer to the USB 2.0 specific
 234:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 235:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \param[in] Direction  Endpoint data direction, either \ref ENDPOINT_DIR_OUT or \ref ENDPOINT
 236:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *                        All endpoints (except Control type) are unidirectional - data may only
 237:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *                        from or written to the endpoint bank based on its direction, not both.
 238:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 239:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \param[in] Size       Size of the endpoint's bank, where packets are stored before they are 
 240:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *                        to the USB host, or after they have been received from the USB host (d
 241:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *                        the endpoint's data direction). The bank size must indicate the maximu
 242:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *                        that the endpoint can handle.
 243:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 244:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \param[in] Banks      Number of banks to use for the endpoint being configured, an \c ENDPOI
 245:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *                        More banks uses more USB DPRAM, but offers better performance. Isochro
 246:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *                        endpoints <b>must</b> have at least two banks.
 247:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 248:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \note When the \c ORDERED_EP_CONFIG compile time option is used, Endpoints <b>must</b> be co
 249:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *        ascending order, or bank corruption will occur.
 250:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *        \n\n
 251:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 252:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \note Different endpoints may have different maximum packet sizes based on the endpoint's in
 253:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *        the chosen microcontroller model's datasheet to determine the maximum bank size for ea
 254:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *        \n\n
 255:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 256:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \note The default control endpoint should not be manually configured by the user application
 257:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *        it is automatically configured by the library internally.
 258:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *        \n\n
 259:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 260:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \note This routine will automatically select the specified endpoint upon success. Upon failu
 261:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *        which failed to reconfigure correctly will be selected.
 262:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 263:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Boolean \c true if the configuration succeeded, \c false otherwise.
 264:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 265:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Number,
 266:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			                                              const uint8_t Type,
 267:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			                                              const uint8_t Direction,
 268:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			                                              const uint16_t Size,
 269:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			                                              const uint8_t Banks) ATTR_ALWAYS_INLINE;
 270:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Number,
 271:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			                                              const uint8_t Type,
 272:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			                                              const uint8_t Direction,
 273:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			                                              const uint16_t Size,
 274:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			                                              const uint8_t Banks)
 275:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 276:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 
 277:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                      ((1 << ALLOC) | Banks | Endpoint_BytesToEPSizeMask(Size))
 278:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 279:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 280:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Indicates the number of bytes currently stored in the current endpoint's selected bank.
 281:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 282:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \note The return width of this function may differ, depending on the maximum endpoint bank s
 283:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *        of the selected AVR model.
 284:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 285:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointRW_AVR8
 286:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 287:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Total number of bytes in the currently selected Endpoint's FIFO buffer.
 288:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 289:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE
 290:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint16_t Endpoint_BytesInEndpoint(void)
 291:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 292:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
 293:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					return UEBCX;
 294:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#elif defined(USB_SERIES_4_AVR)
 295:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					return (((uint16_t)UEBCHX << 8) | UEBCLX);
 296:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#elif defined(USB_SERIES_2_AVR)
 297:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					return UEBCLX;
 298:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 299:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 300:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 301:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Get the endpoint address of the currently selected endpoint. This is typically used to save
 302:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  the currently selected endpoint number so that it can be restored after another endpoint has
 303:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  been manipulated.
 304:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 305:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Index of the currently selected endpoint.
 306:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 307:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLI
 308:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
 309:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 310:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#if !defined(CONTROL_ONLY_DEVICE)
 311:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					return (UENUM & ENDPOINT_EPNUM_MASK);
 312:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 313:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					return ENDPOINT_CONTROLEP;
 314:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 315:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 316:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 317:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Selects the given endpoint number. If the address from the device descriptors is used, the
 318:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  value should be masked with the \ref ENDPOINT_EPNUM_MASK constant to extract only the endpoi
 319:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  number (and discarding the endpoint direction bit).
 320:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 321:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  Any endpoint operations which do not require the endpoint number to be indicated will operat
 322:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  the currently selected endpoint.
 323:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 324:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \param[in] EndpointNumber Endpoint number to select.
 325:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 326:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
 327:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
  26               		.loc 2 327 23 view .LVU2
  27               	.LBB87:
 328:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 329:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#if !defined(CONTROL_ONLY_DEVICE)
 330:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					UENUM = EndpointNumber;
  28               		.loc 2 330 6 view .LVU3
  29               		.loc 2 330 12 is_stmt 0 view .LVU4
  30 0000 84E0      		ldi r24,lo8(4)
  31 0002 8093 E900 		sts 233,r24
  32               	.LVL1:
  33               	.L2:
  34               		.loc 2 330 12 view .LVU5
  35               	.LBE87:
  36               	.LBE86:
 524:Caterina.c    **** 
 525:Caterina.c    ****     /* If OUT endpoint empty, clear it and wait for the next packet from the host */
 526:Caterina.c    ****     while (!(Endpoint_IsReadWriteAllowed()))
  37               		.loc 1 526 11 is_stmt 1 view .LVU6
  38               	.LBB88:
  39               	.LBI88:
 331:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 332:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 333:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 334:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Resets the endpoint bank FIFO. This clears all the endpoint banks and resets the USB control
 335:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  data In and Out pointers to the bank's contents.
 336:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 337:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
 338:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 339:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
 340:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber)
 341:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 342:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				UERST = (1 << EndpointNumber);
 343:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				UERST = 0;
 344:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 345:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 346:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Enables the currently selected endpoint so that data can be sent and received through it to
 347:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  and from a host.
 348:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 349:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
 350:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 351:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
 352:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_EnableEndpoint(void)
 353:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 354:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				UECONX |= (1 << EPEN);
 355:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 356:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 357:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Disables the currently selected endpoint so that data cannot be sent and received through it
 358:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  to and from a host.
 359:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 360:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
 361:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_DisableEndpoint(void)
 362:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 363:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				UECONX &= ~(1 << EPEN);
 364:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 365:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 366:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Determines if the currently selected endpoint is enabled, but not necessarily configured.
 367:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 368:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
 369:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 370:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 371:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsEnabled(void)
 372:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 373:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return ((UECONX & (1 << EPEN)) ? true : false);
 374:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 375:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 376:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Retrieves the number of busy banks in the currently selected endpoint, which have been queue
 377:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  transmission via the \ref Endpoint_ClearIN() command, or are awaiting acknowledgement via th
 378:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ref Endpoint_ClearOUT() command.
 379:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 380:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPacketManagement_AVR8
 381:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 382:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Total number of busy banks in the selected endpoint.
 383:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 384:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint8_t Endpoint_GetBusyBanks(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
 385:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint8_t Endpoint_GetBusyBanks(void)
 386:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 387:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return (UESTA0X & (0x03 << NBUSYBK0));
 388:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 389:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 390:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Aborts all pending IN transactions on the currently selected endpoint, once the bank
 391:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  has been queued for transmission to the host via \ref Endpoint_ClearIN(). This function
 392:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  will terminate all queued transactions, resetting the endpoint banks ready for a new
 393:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  packet.
 394:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 395:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPacketManagement_AVR8
 396:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 397:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_AbortPendingIN(void)
 398:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 399:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				while (Endpoint_GetBusyBanks() != 0)
 400:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				{
 401:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					UEINTX |= (1 << RXOUTI);
 402:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					while (UEINTX & (1 << RXOUTI));
 403:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				}
 404:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 405:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 406:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Determines if the currently selected endpoint may be read from (if data is waiting in the en
 407:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  bank and the endpoint is an OUT direction, or if the bank is not yet full if the endpoint is
 408:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  direction). This function will return false if an error has occurred in the endpoint, if the
 409:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  is an OUT direction and no packet (or an empty packet) has been received, or if the endpoint
 410:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  direction and the endpoint bank is full.
 411:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 412:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPacketManagement_AVR8
 413:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 414:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Boolean \c true if the currently selected endpoint may be read from or written to, d
 415:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *          on its direction.
 416:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 417:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 418:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsReadWriteAllowed(void)
  40               		.loc 2 418 23 view .LVU7
  41               	.LBB89:
 419:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 420:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return ((UEINTX & (1 << RWAL)) ? true : false);
  42               		.loc 2 420 5 view .LVU8
  43               		.loc 2 420 14 is_stmt 0 view .LVU9
  44 0006 8091 E800 		lds r24,232
  45               	.LBE89:
  46               	.LBE88:
  47               		.loc 1 526 11 view .LVU10
  48 000a 85FF      		sbrs r24,5
  49 000c 00C0      		rjmp .L6
 527:Caterina.c    ****     {
 528:Caterina.c    ****         Endpoint_ClearOUT();
 529:Caterina.c    **** 
 530:Caterina.c    ****         while (!(Endpoint_IsOUTReceived()))
 531:Caterina.c    ****         {
 532:Caterina.c    ****             if (USB_DeviceState == DEVICE_STATE_Unattached)
 533:Caterina.c    ****               return 0;
 534:Caterina.c    ****         }
 535:Caterina.c    ****     }
 536:Caterina.c    **** 
 537:Caterina.c    ****     /* Fetch the next byte from the OUT endpoint */
 538:Caterina.c    ****     return Endpoint_Read_8();
  50               		.loc 1 538 5 is_stmt 1 view .LVU11
  51               	.LBB90:
  52               	.LBI90:
 421:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 422:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 423:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Determines if the currently selected endpoint is configured.
 424:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 425:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false oth
 426:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 427:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 428:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsConfigured(void)
 429:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 430:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return ((UESTA0X & (1 << CFGOK)) ? true : false);
 431:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 432:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 433:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Returns a mask indicating which INTERRUPT type endpoints have interrupted - i.e. their
 434:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  interrupt duration has elapsed. Which endpoints have interrupted can be determined by
 435:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  masking the return value against <tt>(1 << <i>{Endpoint Number}</i>)</tt>.
 436:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 437:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Mask whose bits indicate which endpoints have interrupted.
 438:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 439:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint8_t Endpoint_GetEndpointInterrupts(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_I
 440:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint8_t Endpoint_GetEndpointInterrupts(void)
 441:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 442:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return UEINT;
 443:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 444:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 445:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Determines if the specified endpoint number has interrupted (valid only for INTERRUPT type
 446:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  endpoints).
 447:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 448:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \param[in] EndpointNumber  Index of the endpoint whose interrupt flag should be tested.
 449:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 450:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Boolean \c true if the specified endpoint has interrupted, \c false otherwise.
 451:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 452:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_HasEndpointInterrupted(const uint8_t EndpointNumber) ATTR_WARN_UNUSE
 453:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_HasEndpointInterrupted(const uint8_t EndpointNumber)
 454:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 455:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return ((Endpoint_GetEndpointInterrupts() & (1 << EndpointNumber)) ? true : false);
 456:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 457:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 458:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Determines if the selected IN endpoint is ready for a new packet to be sent to the host.
 459:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 460:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPacketManagement_AVR8
 461:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 462:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwis
 463:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 464:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 465:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsINReady(void)
 466:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 467:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return ((UEINTX & (1 << TXINI)) ? true : false);
 468:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 469:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 470:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Determines if the selected OUT endpoint has received new packet from the host.
 471:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 472:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPacketManagement_AVR8
 473:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 474:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwis
 475:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 476:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 477:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsOUTReceived(void)
 478:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 479:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return ((UEINTX & (1 << RXOUTI)) ? true : false);
 480:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 481:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 482:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Determines if the current CONTROL type endpoint has received a SETUP packet.
 483:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 484:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPacketManagement_AVR8
 485:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 486:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false other
 487:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 488:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 489:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsSETUPReceived(void)
 490:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 491:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return ((UEINTX & (1 << RXSTPI)) ? true : false);
 492:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 493:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 494:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Clears a received SETUP packet on the currently selected CONTROL type endpoint, freeing up t
 495:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  endpoint for the next packet.
 496:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 497:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPacketManagement_AVR8
 498:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 499:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \note This is not applicable for non CONTROL type endpoints.
 500:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 501:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
 502:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_ClearSETUP(void)
 503:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 504:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				UEINTX &= ~(1 << RXSTPI);
 505:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 506:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 507:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Sends an IN packet to the host on the currently selected endpoint, freeing up the endpoint f
 508:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  next packet and switching to the alternative endpoint bank if double banked.
 509:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 510:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPacketManagement_AVR8
 511:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 512:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
 513:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_ClearIN(void)
 514:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 515:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#if !defined(CONTROL_ONLY_DEVICE)
 516:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
 517:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 518:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					UEINTX &= ~(1 << TXINI);
 519:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 520:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 521:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 522:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Acknowledges an OUT packet to the host on the currently selected endpoint, freeing up the en
 523:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  for the next packet and switching to the alternative endpoint bank if double banked.
 524:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 525:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPacketManagement_AVR8
 526:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 527:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
 528:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_ClearOUT(void)
 529:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 530:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#if !defined(CONTROL_ONLY_DEVICE)
 531:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
 532:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 533:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					UEINTX &= ~(1 << RXOUTI);
 534:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 535:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 536:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 537:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Stalls the current endpoint, indicating to the host that a logical problem occurred with the
 538:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  indicated endpoint and that the current transfer sequence should be aborted. This provides a
 539:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  way for devices to indicate invalid commands to the host so that the current transfer can be
 540:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  aborted and the host can begin its own recovery sequence.
 541:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 542:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  The currently selected endpoint remains stalled until either the \ref Endpoint_ClearStall() 
 543:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  is called, or the host issues a CLEAR FEATURE request to the device for the currently select
 544:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  endpoint.
 545:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 546:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPacketManagement_AVR8
 547:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 548:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
 549:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_StallTransaction(void)
 550:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 551:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				UECONX |= (1 << STALLRQ);
 552:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 553:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 554:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Clears the STALL condition on the currently selected endpoint.
 555:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 556:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPacketManagement_AVR8
 557:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 558:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
 559:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_ClearStall(void)
 560:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 561:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				UECONX |= (1 << STALLRQC);
 562:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 563:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 564:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Determines if the currently selected endpoint is stalled, false otherwise.
 565:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 566:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPacketManagement_AVR8
 567:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 568:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
 569:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 570:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 571:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline bool Endpoint_IsStalled(void)
 572:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 573:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return ((UECONX & (1 << STALLRQ)) ? true : false);
 574:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 575:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 576:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Resets the data toggle of the currently selected endpoint. */
 577:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
 578:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_ResetDataToggle(void)
 579:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 580:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				UECONX |= (1 << RSTDT);
 581:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 582:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 583:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Determines the currently selected endpoint's direction.
 584:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 585:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
 586:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 587:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_IN
 588:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint8_t Endpoint_GetEndpointDirection(void)
 589:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 590:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
 591:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 592:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 593:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Sets the direction of the currently selected endpoint.
 594:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 595:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \param[in] DirectionMask  New endpoint direction, as a \c ENDPOINT_DIR_* mask.
 596:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 597:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_SetEndpointDirection(const uint8_t DirectionMask) ATTR_ALWAYS_INLINE
 598:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_SetEndpointDirection(const uint8_t DirectionMask)
 599:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 600:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				UECFG0X = ((UECFG0X & ~(1 << EPDIR)) | (DirectionMask ? (1 << EPDIR) : 0));
 601:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 602:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 603:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Reads one byte from the currently selected endpoint's bank, for OUT direction endpoints.
 604:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 605:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPrimitiveRW_AVR8
 606:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 607:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
 608:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 609:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 610:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline uint8_t Endpoint_Read_8(void)
  53               		.loc 2 610 26 view .LVU12
  54               	.LBB91:
 611:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 612:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				return UEDATX;
  55               		.loc 2 612 5 view .LVU13
  56               		.loc 2 612 12 is_stmt 0 view .LVU14
  57 000e 8091 F100 		lds r24,241
  58               	.LBE91:
  59               	.LBE90:
  60               		.loc 1 538 12 view .LVU15
  61 0012 00C0      		rjmp .L1
  62               	.L6:
 528:Caterina.c    **** 
  63               		.loc 1 528 9 is_stmt 1 view .LVU16
  64               	.LBB92:
  65               	.LBI92:
 528:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
  66               		.loc 2 528 23 view .LVU17
  67               	.LBB93:
 531:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
  68               		.loc 2 531 6 view .LVU18
 531:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
  69               		.loc 2 531 13 is_stmt 0 view .LVU19
  70 0014 8091 E800 		lds r24,232
  71 0018 8B77      		andi r24,lo8(123)
  72 001a 8093 E800 		sts 232,r24
  73               	.L3:
  74               	.LBE93:
  75               	.LBE92:
 530:Caterina.c    ****         {
  76               		.loc 1 530 15 is_stmt 1 view .LVU20
  77               	.LBB94:
  78               	.LBI94:
 477:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
  79               		.loc 2 477 23 view .LVU21
  80               	.LBB95:
 479:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
  81               		.loc 2 479 5 view .LVU22
 479:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
  82               		.loc 2 479 14 is_stmt 0 view .LVU23
  83 001e 8091 E800 		lds r24,232
  84               	.LBE95:
  85               	.LBE94:
 530:Caterina.c    ****         {
  86               		.loc 1 530 15 view .LVU24
  87 0022 82FD      		sbrc r24,2
  88 0024 00C0      		rjmp .L2
 532:Caterina.c    ****               return 0;
  89               		.loc 1 532 13 is_stmt 1 view .LVU25
 532:Caterina.c    ****               return 0;
  90               		.loc 1 532 17 is_stmt 0 view .LVU26
  91 0026 8EB3      		in r24,0x1e
 532:Caterina.c    ****               return 0;
  92               		.loc 1 532 16 view .LVU27
  93 0028 8111      		cpse r24,__zero_reg__
  94 002a 00C0      		rjmp .L3
  95               	.L1:
  96               	/* epilogue start */
 539:Caterina.c    **** }
  97               		.loc 1 539 1 view .LVU28
  98 002c 0895      		ret
  99               		.cfi_endproc
 100               	.LFE114:
 102               		.section	.text.WriteNextResponseByte,"ax",@progbits
 104               	WriteNextResponseByte:
 105               	.LVL2:
 106               	.LFB115:
 540:Caterina.c    **** 
 541:Caterina.c    **** /** Writes the next response byte to the CDC data IN endpoint, and sends the endpoint back if neede
 542:Caterina.c    ****  *  bank when full ready for the next byte in the packet to the host.
 543:Caterina.c    ****  *
 544:Caterina.c    ****  *  \param[in] Response  Next response byte to send to the host
 545:Caterina.c    ****  */
 546:Caterina.c    **** static void WriteNextResponseByte(const uint8_t Response)
 547:Caterina.c    **** {
 107               		.loc 1 547 1 is_stmt 1 view -0
 108               		.cfi_startproc
 109               	/* prologue: function */
 110               	/* frame size = 0 */
 111               	/* stack size = 0 */
 112               	.L__stack_usage = 0
 548:Caterina.c    ****     /* Select the IN endpoint so that the next data byte can be written */
 549:Caterina.c    ****     Endpoint_SelectEndpoint(CDC_TX_EPNUM);
 113               		.loc 1 549 5 view .LVU30
 114               	.LBB96:
 115               	.LBI96:
 327:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 116               		.loc 2 327 23 view .LVU31
 117               	.LBB97:
 330:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 118               		.loc 2 330 6 view .LVU32
 330:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 119               		.loc 2 330 12 is_stmt 0 view .LVU33
 120 0000 93E0      		ldi r25,lo8(3)
 121 0002 9093 E900 		sts 233,r25
 122               	.LVL3:
 330:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 123               		.loc 2 330 12 view .LVU34
 124               	.LBE97:
 125               	.LBE96:
 550:Caterina.c    **** 
 551:Caterina.c    ****     /* If IN endpoint full, clear it and wait until ready for the next packet to the host */
 552:Caterina.c    ****     if (!(Endpoint_IsReadWriteAllowed()))
 126               		.loc 1 552 5 is_stmt 1 view .LVU35
 127               	.LBB98:
 128               	.LBI98:
 418:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 129               		.loc 2 418 23 view .LVU36
 130               	.LBB99:
 420:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 131               		.loc 2 420 5 view .LVU37
 420:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 132               		.loc 2 420 14 is_stmt 0 view .LVU38
 133 0006 9091 E800 		lds r25,232
 134               	.LBE99:
 135               	.LBE98:
 136               		.loc 1 552 8 view .LVU39
 137 000a 95FF      		sbrs r25,5
 138 000c 00C0      		rjmp .L11
 139               	.L14:
 553:Caterina.c    ****     {
 554:Caterina.c    ****         Endpoint_ClearIN();
 555:Caterina.c    **** 
 556:Caterina.c    ****         while (!(Endpoint_IsINReady()))
 557:Caterina.c    ****         {
 558:Caterina.c    ****             if (USB_DeviceState == DEVICE_STATE_Unattached)
 559:Caterina.c    ****               return;
 560:Caterina.c    ****         }
 561:Caterina.c    ****     }
 562:Caterina.c    **** 
 563:Caterina.c    ****     /* Write the next byte to the IN endpoint */
 564:Caterina.c    ****     Endpoint_Write_8(Response);
 140               		.loc 1 564 5 is_stmt 1 view .LVU40
 141               	.LVL4:
 142               	.LBB100:
 143               	.LBI100:
 613:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 614:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 615:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			/** Writes one byte to the currently selected endpoint's bank, for IN direction endpoints.
 616:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 617:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \ingroup Group_EndpointPrimitiveRW_AVR8
 618:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *
 619:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
 620:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			 */
 621:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
 622:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			static inline void Endpoint_Write_8(const uint8_t Data)
 144               		.loc 2 622 23 view .LVU41
 145               	.LBB101:
 623:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 624:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				UEDATX = Data;
 146               		.loc 2 624 5 view .LVU42
 147               		.loc 2 624 12 is_stmt 0 view .LVU43
 148 000e 8093 F100 		sts 241,r24
 149               	.LVL5:
 150               		.loc 2 624 12 view .LVU44
 151               	.LBE101:
 152               	.LBE100:
 565:Caterina.c    **** 
 566:Caterina.c    ****     TX_LED_ON();
 153               		.loc 1 566 5 is_stmt 1 view .LVU45
 154 0012 5B98      		cbi 0xb,3
 567:Caterina.c    ****     TxLEDPulse = TX_RX_LED_PULSE_PERIOD;
 155               		.loc 1 567 5 view .LVU46
 156               		.loc 1 567 16 is_stmt 0 view .LVU47
 157 0014 84E6      		ldi r24,lo8(100)
 158 0016 90E0      		ldi r25,0
 159               	.LVL6:
 160               		.loc 1 567 16 view .LVU48
 161 0018 9093 0000 		sts TxLEDPulse+1,r25
 162 001c 8093 0000 		sts TxLEDPulse,r24
 163               	.LVL7:
 164               		.loc 1 567 16 view .LVU49
 165 0020 0895      		ret
 166               	.LVL8:
 167               	.L11:
 554:Caterina.c    **** 
 168               		.loc 1 554 9 is_stmt 1 view .LVU50
 169               	.LBB102:
 170               	.LBI102:
 513:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 171               		.loc 2 513 23 view .LVU51
 172               	.LBB103:
 516:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 173               		.loc 2 516 6 view .LVU52
 516:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 174               		.loc 2 516 13 is_stmt 0 view .LVU53
 175 0022 9091 E800 		lds r25,232
 176 0026 9E77      		andi r25,lo8(126)
 177 0028 9093 E800 		sts 232,r25
 178               	.L13:
 179               	.LBE103:
 180               	.LBE102:
 556:Caterina.c    ****         {
 181               		.loc 1 556 15 is_stmt 1 view .LVU54
 182               	.LBB104:
 183               	.LBI104:
 465:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 184               		.loc 2 465 23 view .LVU55
 185               	.LBB105:
 467:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 186               		.loc 2 467 5 view .LVU56
 467:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 187               		.loc 2 467 14 is_stmt 0 view .LVU57
 188 002c 9091 E800 		lds r25,232
 189               	.LBE105:
 190               	.LBE104:
 556:Caterina.c    ****         {
 191               		.loc 1 556 15 view .LVU58
 192 0030 90FD      		sbrc r25,0
 193 0032 00C0      		rjmp .L14
 558:Caterina.c    ****               return;
 194               		.loc 1 558 13 is_stmt 1 view .LVU59
 558:Caterina.c    ****               return;
 195               		.loc 1 558 17 is_stmt 0 view .LVU60
 196 0034 9EB3      		in r25,0x1e
 558:Caterina.c    ****               return;
 197               		.loc 1 558 16 view .LVU61
 198 0036 9111      		cpse r25,__zero_reg__
 199 0038 00C0      		rjmp .L13
 200               	/* epilogue start */
 568:Caterina.c    **** }
 201               		.loc 1 568 1 view .LVU62
 202 003a 0895      		ret
 203               		.cfi_endproc
 204               	.LFE115:
 206               		.section	.text.StartSketch,"ax",@progbits
 207               	.global	StartSketch
 209               	StartSketch:
 210               	.LFB99:
 108:Caterina.c    ****     cli();
 211               		.loc 1 108 1 is_stmt 1 view -0
 212               		.cfi_startproc
 213               	/* prologue: function */
 214               	/* frame size = 0 */
 215               	/* stack size = 0 */
 216               	.L__stack_usage = 0
 109:Caterina.c    **** 
 217               		.loc 1 109 5 view .LVU64
 218               	/* #APP */
 219               	 ;  109 "Caterina.c" 1
 220 0000 F894      		cli
 221               	 ;  0 "" 2
 112:Caterina.c    ****     TCCR1B = 0;
 222               		.loc 1 112 5 view .LVU65
 112:Caterina.c    ****     TCCR1B = 0;
 223               		.loc 1 112 12 is_stmt 0 view .LVU66
 224               	/* #NOAPP */
 225 0002 1092 6F00 		sts 111,__zero_reg__
 113:Caterina.c    ****     TCNT1H = 0;		// 16-bit write to TCNT1 requires high byte be written first
 226               		.loc 1 113 5 is_stmt 1 view .LVU67
 113:Caterina.c    ****     TCNT1H = 0;		// 16-bit write to TCNT1 requires high byte be written first
 227               		.loc 1 113 12 is_stmt 0 view .LVU68
 228 0006 1092 8100 		sts 129,__zero_reg__
 114:Caterina.c    ****     TCNT1L = 0;
 229               		.loc 1 114 5 is_stmt 1 view .LVU69
 114:Caterina.c    ****     TCNT1L = 0;
 230               		.loc 1 114 12 is_stmt 0 view .LVU70
 231 000a 1092 8500 		sts 133,__zero_reg__
 115:Caterina.c    **** 
 232               		.loc 1 115 5 is_stmt 1 view .LVU71
 115:Caterina.c    **** 
 233               		.loc 1 115 12 is_stmt 0 view .LVU72
 234 000e 1092 8400 		sts 132,__zero_reg__
 118:Caterina.c    ****     MCUCR = 0;
 235               		.loc 1 118 5 is_stmt 1 view .LVU73
 118:Caterina.c    ****     MCUCR = 0;
 236               		.loc 1 118 11 is_stmt 0 view .LVU74
 237 0012 81E0      		ldi r24,lo8(1)
 238 0014 85BF      		out 0x35,r24
 119:Caterina.c    **** 
 239               		.loc 1 119 5 is_stmt 1 view .LVU75
 119:Caterina.c    **** 
 240               		.loc 1 119 11 is_stmt 0 view .LVU76
 241 0016 15BE      		out 0x35,__zero_reg__
 121:Caterina.c    ****     TX_LED_OFF();
 242               		.loc 1 121 5 is_stmt 1 view .LVU77
 243 0018 4798      		cbi 0x8,7
 122:Caterina.c    ****     RX_LED_OFF();
 244               		.loc 1 122 5 view .LVU78
 245 001a 5B9A      		sbi 0xb,3
 123:Caterina.c    **** 
 246               		.loc 1 123 5 view .LVU79
 247 001c 5A9A      		sbi 0xb,2
 126:Caterina.c    **** }
 248               		.loc 1 126 5 view .LVU80
 249               	/* #APP */
 250               	 ;  126 "Caterina.c" 1
 251 001e 0C94 0000 		jmp 0x0000
 252               	 ;  0 "" 2
 253               	/* #NOAPP */
 254               	/* epilogue start */
 127:Caterina.c    **** 
 255               		.loc 1 127 1 is_stmt 0 view .LVU81
 256 0022 0895      		ret
 257               		.cfi_endproc
 258               	.LFE99:
 260               		.section	.text.TWIInit,"ax",@progbits
 261               	.global	TWIInit
 263               	TWIInit:
 264               	.LFB100:
 130:Caterina.c    ****     /* Set SCL frequency to ~200kHz */
 265               		.loc 1 130 1 is_stmt 1 view -0
 266               		.cfi_startproc
 267               	/* prologue: function */
 268               	/* frame size = 0 */
 269               	/* stack size = 0 */
 270               	.L__stack_usage = 0
 132:Caterina.c    ****     TWBR = 0x0C;
 271               		.loc 1 132 5 view .LVU83
 132:Caterina.c    ****     TWBR = 0x0C;
 272               		.loc 1 132 10 is_stmt 0 view .LVU84
 273 0000 1092 B900 		sts 185,__zero_reg__
 133:Caterina.c    **** 
 274               		.loc 1 133 5 is_stmt 1 view .LVU85
 133:Caterina.c    **** 
 275               		.loc 1 133 10 is_stmt 0 view .LVU86
 276 0004 8CE0      		ldi r24,lo8(12)
 277 0006 8093 B800 		sts 184,r24
 136:Caterina.c    **** }
 278               		.loc 1 136 5 is_stmt 1 view .LVU87
 136:Caterina.c    **** }
 279               		.loc 1 136 10 is_stmt 0 view .LVU88
 280 000a 84E0      		ldi r24,lo8(4)
 281 000c 8093 BC00 		sts 188,r24
 282               	/* epilogue start */
 137:Caterina.c    **** 
 283               		.loc 1 137 1 view .LVU89
 284 0010 0895      		ret
 285               		.cfi_endproc
 286               	.LFE100:
 288               		.section	.text.TWIStart,"ax",@progbits
 289               	.global	TWIStart
 291               	TWIStart:
 292               	.LFB101:
 140:Caterina.c    ****     /* Send START condition */
 293               		.loc 1 140 1 is_stmt 1 view -0
 294               		.cfi_startproc
 295               	/* prologue: function */
 296               	/* frame size = 0 */
 297               	/* stack size = 0 */
 298               	.L__stack_usage = 0
 142:Caterina.c    ****     /* Wait for TWINT Flag set. This indicates that the START condition has been transmitted */
 299               		.loc 1 142 5 view .LVU91
 142:Caterina.c    ****     /* Wait for TWINT Flag set. This indicates that the START condition has been transmitted */
 300               		.loc 1 142 10 is_stmt 0 view .LVU92
 301 0000 84EA      		ldi r24,lo8(-92)
 302 0002 8093 BC00 		sts 188,r24
 144:Caterina.c    **** }
 303               		.loc 1 144 5 is_stmt 1 view .LVU93
 304               	.L23:
 144:Caterina.c    **** }
 305               		.loc 1 144 32 discriminator 1 view .LVU94
 144:Caterina.c    **** }
 306               		.loc 1 144 10 discriminator 1 view .LVU95
 144:Caterina.c    **** }
 307               		.loc 1 144 13 is_stmt 0 discriminator 1 view .LVU96
 308 0006 8091 BC00 		lds r24,188
 144:Caterina.c    **** }
 309               		.loc 1 144 10 discriminator 1 view .LVU97
 310 000a 87FF      		sbrs r24,7
 311 000c 00C0      		rjmp .L23
 312               	/* epilogue start */
 145:Caterina.c    **** 
 313               		.loc 1 145 1 view .LVU98
 314 000e 0895      		ret
 315               		.cfi_endproc
 316               	.LFE101:
 318               		.section	.text.TWIStop,"ax",@progbits
 319               	.global	TWIStop
 321               	TWIStop:
 322               	.LFB102:
 148:Caterina.c    ****     TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWSTO);
 323               		.loc 1 148 1 is_stmt 1 view -0
 324               		.cfi_startproc
 325               	/* prologue: function */
 326               	/* frame size = 0 */
 327               	/* stack size = 0 */
 328               	.L__stack_usage = 0
 149:Caterina.c    **** }
 329               		.loc 1 149 5 view .LVU100
 149:Caterina.c    **** }
 330               		.loc 1 149 10 is_stmt 0 view .LVU101
 331 0000 84E9      		ldi r24,lo8(-108)
 332 0002 8093 BC00 		sts 188,r24
 333               	/* epilogue start */
 150:Caterina.c    **** 
 334               		.loc 1 150 1 view .LVU102
 335 0006 0895      		ret
 336               		.cfi_endproc
 337               	.LFE102:
 339               		.section	.text.TWIWrite,"ax",@progbits
 340               	.global	TWIWrite
 342               	TWIWrite:
 343               	.LVL9:
 344               	.LFB103:
 153:Caterina.c    ****     /* Load data into TWDR Register. Clear TWINT bit in TWCR to start transmission */
 345               		.loc 1 153 1 is_stmt 1 view -0
 346               		.cfi_startproc
 347               	/* prologue: function */
 348               	/* frame size = 0 */
 349               	/* stack size = 0 */
 350               	.L__stack_usage = 0
 155:Caterina.c    ****     TWCR = (1<<TWINT)|(1<<TWEN);
 351               		.loc 1 155 5 view .LVU104
 155:Caterina.c    ****     TWCR = (1<<TWINT)|(1<<TWEN);
 352               		.loc 1 155 10 is_stmt 0 view .LVU105
 353 0000 8093 BB00 		sts 187,r24
 156:Caterina.c    ****     /* Wait for TWINT Flag set. This indicates that the data has been transmitted, and ACK/NACK has
 354               		.loc 1 156 5 is_stmt 1 view .LVU106
 156:Caterina.c    ****     /* Wait for TWINT Flag set. This indicates that the data has been transmitted, and ACK/NACK has
 355               		.loc 1 156 10 is_stmt 0 view .LVU107
 356 0004 84E8      		ldi r24,lo8(-124)
 357               	.LVL10:
 156:Caterina.c    ****     /* Wait for TWINT Flag set. This indicates that the data has been transmitted, and ACK/NACK has
 358               		.loc 1 156 10 view .LVU108
 359 0006 8093 BC00 		sts 188,r24
 360               	.LVL11:
 158:Caterina.c    **** }
 361               		.loc 1 158 5 is_stmt 1 view .LVU109
 362               	.L27:
 158:Caterina.c    **** }
 363               		.loc 1 158 32 discriminator 1 view .LVU110
 158:Caterina.c    **** }
 364               		.loc 1 158 10 discriminator 1 view .LVU111
 158:Caterina.c    **** }
 365               		.loc 1 158 13 is_stmt 0 discriminator 1 view .LVU112
 366 000a 8091 BC00 		lds r24,188
 158:Caterina.c    **** }
 367               		.loc 1 158 10 discriminator 1 view .LVU113
 368 000e 87FF      		sbrs r24,7
 369 0010 00C0      		rjmp .L27
 370               	/* epilogue start */
 159:Caterina.c    **** 
 371               		.loc 1 159 1 view .LVU114
 372 0012 0895      		ret
 373               		.cfi_endproc
 374               	.LFE103:
 376               		.section	.text.SetupCurrentLimit,"ax",@progbits
 377               	.global	SetupCurrentLimit
 379               	SetupCurrentLimit:
 380               	.LFB104:
 162:Caterina.c    ****     /* Initialize I2C */
 381               		.loc 1 162 1 is_stmt 1 view -0
 382               		.cfi_startproc
 383               	/* prologue: function */
 384               	/* frame size = 0 */
 385               	/* stack size = 0 */
 386               	.L__stack_usage = 0
 164:Caterina.c    **** 
 387               		.loc 1 164 5 view .LVU116
 388 0000 0E94 0000 		call TWIStart
 389               	.LVL12:
 167:Caterina.c    **** 
 390               		.loc 1 167 5 view .LVU117
 391 0004 8EE5      		ldi r24,lo8(94)
 392 0006 0E94 0000 		call TWIWrite
 393               	.LVL13:
 170:Caterina.c    **** 
 394               		.loc 1 170 5 view .LVU118
 395 000a 80E0      		ldi r24,0
 396 000c 0E94 0000 		call TWIWrite
 397               	.LVL14:
 172:Caterina.c    **** }
 398               		.loc 1 172 5 view .LVU119
 399               	.LBB108:
 400               	.LBI108:
 147:Caterina.c    **** {
 401               		.loc 1 147 6 view .LVU120
 402               	.LBB109:
 149:Caterina.c    **** }
 403               		.loc 1 149 5 view .LVU121
 149:Caterina.c    **** }
 404               		.loc 1 149 10 is_stmt 0 view .LVU122
 405 0010 84E9      		ldi r24,lo8(-108)
 406 0012 8093 BC00 		sts 188,r24
 407               	/* epilogue start */
 408               	.LBE109:
 409               	.LBE108:
 173:Caterina.c    **** 
 410               		.loc 1 173 1 view .LVU123
 411 0016 0895      		ret
 412               		.cfi_endproc
 413               	.LFE104:
 415               		.section	.text.ReadBatteryVoltage,"ax",@progbits
 416               	.global	ReadBatteryVoltage
 418               	ReadBatteryVoltage:
 419               	.LFB105:
 176:Caterina.c    ****     /* Set PINF0 to Input */
 420               		.loc 1 176 1 is_stmt 1 view -0
 421               		.cfi_startproc
 422               	/* prologue: function */
 423               	/* frame size = 0 */
 424               	/* stack size = 0 */
 425               	.L__stack_usage = 0
 178:Caterina.c    ****     PORTF |= (1 << PF0);
 426               		.loc 1 178 5 view .LVU125
 178:Caterina.c    ****     PORTF |= (1 << PF0);
 427               		.loc 1 178 10 is_stmt 0 view .LVU126
 428 0000 8098      		cbi 0x10,0
 179:Caterina.c    **** 
 429               		.loc 1 179 5 is_stmt 1 view .LVU127
 179:Caterina.c    **** 
 430               		.loc 1 179 11 is_stmt 0 view .LVU128
 431 0002 889A      		sbi 0x11,0
 181:Caterina.c    **** 
 432               		.loc 1 181 5 is_stmt 1 view .LVU129
 184:Caterina.c    ****     /* Set ADC Mux to ADC0 */
 433               		.loc 1 184 5 view .LVU130
 184:Caterina.c    ****     /* Set ADC Mux to ADC0 */
 434               		.loc 1 184 11 is_stmt 0 view .LVU131
 435 0004 8091 7C00 		lds r24,124
 436 0008 806C      		ori r24,lo8(-64)
 437 000a 8093 7C00 		sts 124,r24
 186:Caterina.c    ****     _delay_ms(1); // Just to be safe
 438               		.loc 1 186 5 is_stmt 1 view .LVU132
 186:Caterina.c    ****     _delay_ms(1); // Just to be safe
 439               		.loc 1 186 11 is_stmt 0 view .LVU133
 440 000e 8091 7C00 		lds r24,124
 441 0012 807E      		andi r24,lo8(-32)
 442 0014 8093 7C00 		sts 124,r24
 187:Caterina.c    **** 
 443               		.loc 1 187 5 is_stmt 1 view .LVU134
 444               	.LVL15:
 445               	.LBB110:
 446               	.LBI110:
 447               		.file 3 "/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** _delay_ms(double __ms)
 448               		.loc 3 166 1 view .LVU135
 449               	.LBB111:
 167:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	double __tmp ;
 450               		.loc 3 168 2 view .LVU136
 169:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 451               		.loc 3 172 2 view .LVU137
 173:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 452               		.loc 3 173 2 view .LVU138
 174:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 453               		.loc 3 174 2 view .LVU139
 175:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 454               		.loc 3 184 3 view .LVU140
 185:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 455               		.loc 3 187 2 view .LVU141
 456 0018 8FEC      		ldi r24,lo8(1999)
 457 001a 97E0      		ldi r25,hi8(1999)
 458 001c 0197      	1:	sbiw r24,1
 459 001e 01F4      		brne 1b
 460 0020 00C0      		rjmp .
 461 0022 0000      		nop
 462               	.LVL16:
 463               		.loc 3 187 2 is_stmt 0 view .LVU142
 464               	.LBE111:
 465               	.LBE110:
 190:Caterina.c    **** 
 466               		.loc 1 190 5 is_stmt 1 view .LVU143
 190:Caterina.c    **** 
 467               		.loc 1 190 12 is_stmt 0 view .LVU144
 468 0024 8091 7A00 		lds r24,122
 469 0028 8064      		ori r24,lo8(64)
 470 002a 8093 7A00 		sts 122,r24
 193:Caterina.c    **** 
 471               		.loc 1 193 5 is_stmt 1 view .LVU145
 472               	.L31:
 193:Caterina.c    **** 
 473               		.loc 1 193 37 discriminator 1 view .LVU146
 193:Caterina.c    **** 
 474               		.loc 1 193 11 discriminator 1 view .LVU147
 193:Caterina.c    **** 
 475               		.loc 1 193 12 is_stmt 0 discriminator 1 view .LVU148
 476 002e 8091 7A00 		lds r24,122
 193:Caterina.c    **** 
 477               		.loc 1 193 11 discriminator 1 view .LVU149
 478 0032 86FD      		sbrc r24,6
 479 0034 00C0      		rjmp .L31
 199:Caterina.c    ****     high = ADCH;
 480               		.loc 1 199 5 is_stmt 1 view .LVU150
 199:Caterina.c    ****     high = ADCH;
 481               		.loc 1 199 9 is_stmt 0 view .LVU151
 482 0036 8091 7800 		lds r24,120
 483               	.LVL17:
 200:Caterina.c    **** 
 484               		.loc 1 200 5 is_stmt 1 view .LVU152
 200:Caterina.c    **** 
 485               		.loc 1 200 10 is_stmt 0 view .LVU153
 486 003a 9091 7900 		lds r25,121
 487               	.LVL18:
 203:Caterina.c    **** }
 488               		.loc 1 203 5 is_stmt 1 view .LVU154
 489               	/* epilogue start */
 204:Caterina.c    **** 
 490               		.loc 1 204 1 is_stmt 0 view .LVU155
 491 003e 0895      		ret
 492               		.cfi_endproc
 493               	.LFE105:
 495               		.section	.text.AlertFatalError,"ax",@progbits
 496               	.global	AlertFatalError
 498               	AlertFatalError:
 499               	.LFB106:
 207:Caterina.c    ****     /* Blink like mad */
 500               		.loc 1 207 1 is_stmt 1 view -0
 501               		.cfi_startproc
 502               	/* prologue: function */
 503               	/* frame size = 0 */
 504               	/* stack size = 0 */
 505               	.L__stack_usage = 0
 506               	.L34:
 209:Caterina.c    ****     {
 507               		.loc 1 209 5 discriminator 1 view .LVU157
 211:Caterina.c    ****         RX_LED_ON();
 508               		.loc 1 211 9 discriminator 1 view .LVU158
 509 0000 5B98      		cbi 0xb,3
 212:Caterina.c    ****         L_LED_ON();
 510               		.loc 1 212 9 discriminator 1 view .LVU159
 511 0002 5A98      		cbi 0xb,2
 213:Caterina.c    ****         _delay_ms(100);
 512               		.loc 1 213 9 discriminator 1 view .LVU160
 513 0004 479A      		sbi 0x8,7
 214:Caterina.c    ****         TX_LED_OFF();
 514               		.loc 1 214 9 discriminator 1 view .LVU161
 515               	.LVL19:
 516               	.LBB112:
 517               	.LBI112:
 166:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** {
 518               		.loc 3 166 1 discriminator 1 view .LVU162
 519               	.LBB113:
 168:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 520               		.loc 3 168 2 discriminator 1 view .LVU163
 172:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 521               		.loc 3 172 2 discriminator 1 view .LVU164
 173:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 522               		.loc 3 173 2 discriminator 1 view .LVU165
 174:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 523               		.loc 3 174 2 discriminator 1 view .LVU166
 184:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	#endif
 524               		.loc 3 184 3 discriminator 1 view .LVU167
 525               		.loc 3 187 2 discriminator 1 view .LVU168
 526 0006 2FEF      		ldi r18,lo8(159999)
 527 0008 80E7      		ldi r24,hi8(159999)
 528 000a 92E0      		ldi r25,hlo8(159999)
 529 000c 2150      	1:	subi r18,1
 530 000e 8040      		sbci r24,0
 531 0010 9040      		sbci r25,0
 532 0012 01F4      		brne 1b
 533 0014 00C0      		rjmp .
 534 0016 0000      		nop
 535               	.LVL20:
 536               		.loc 3 187 2 is_stmt 0 discriminator 1 view .LVU169
 537               	.LBE113:
 538               	.LBE112:
 215:Caterina.c    ****         RX_LED_OFF();
 539               		.loc 1 215 9 is_stmt 1 discriminator 1 view .LVU170
 540 0018 5B9A      		sbi 0xb,3
 216:Caterina.c    ****         L_LED_OFF();
 541               		.loc 1 216 9 discriminator 1 view .LVU171
 542 001a 5A9A      		sbi 0xb,2
 217:Caterina.c    ****         _delay_ms(100);
 543               		.loc 1 217 9 discriminator 1 view .LVU172
 544 001c 4798      		cbi 0x8,7
 218:Caterina.c    ****     }
 545               		.loc 1 218 9 discriminator 1 view .LVU173
 546               	.LVL21:
 547               	.LBB114:
 548               	.LBI114:
 166:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** {
 549               		.loc 3 166 1 discriminator 1 view .LVU174
 550               	.LBB115:
 168:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 551               		.loc 3 168 2 discriminator 1 view .LVU175
 172:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 552               		.loc 3 172 2 discriminator 1 view .LVU176
 173:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 553               		.loc 3 173 2 discriminator 1 view .LVU177
 174:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 554               		.loc 3 174 2 discriminator 1 view .LVU178
 184:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	#endif
 555               		.loc 3 184 3 discriminator 1 view .LVU179
 556               		.loc 3 187 2 discriminator 1 view .LVU180
 557 001e 2FEF      		ldi r18,lo8(159999)
 558 0020 80E7      		ldi r24,hi8(159999)
 559 0022 92E0      		ldi r25,hlo8(159999)
 560 0024 2150      	1:	subi r18,1
 561 0026 8040      		sbci r24,0
 562 0028 9040      		sbci r25,0
 563 002a 01F4      		brne 1b
 564 002c 00C0      		rjmp .
 565 002e 0000      		nop
 566 0030 00C0      		rjmp .L34
 567               	.LBE115:
 568               	.LBE114:
 569               		.cfi_endproc
 570               	.LFE106:
 572               		.section	.text.LEDPulse,"ax",@progbits
 573               	.global	LEDPulse
 575               	LEDPulse:
 576               	.LFB107:
 226:Caterina.c    ****     LLEDPulse++;
 577               		.loc 1 226 1 view -0
 578               		.cfi_startproc
 579               	/* prologue: function */
 580               	/* frame size = 0 */
 581               	/* stack size = 0 */
 582               	.L__stack_usage = 0
 227:Caterina.c    ****     uint8_t p = LLEDPulse >> 8;
 583               		.loc 1 227 5 view .LVU182
 227:Caterina.c    ****     uint8_t p = LLEDPulse >> 8;
 584               		.loc 1 227 14 is_stmt 0 view .LVU183
 585 0000 2091 0000 		lds r18,LLEDPulse
 586 0004 3091 0000 		lds r19,LLEDPulse+1
 587 0008 2F5F      		subi r18,-1
 588 000a 3F4F      		sbci r19,-1
 589 000c 3093 0000 		sts LLEDPulse+1,r19
 590 0010 2093 0000 		sts LLEDPulse,r18
 228:Caterina.c    ****     if (p > 127)
 591               		.loc 1 228 5 is_stmt 1 view .LVU184
 228:Caterina.c    ****     if (p > 127)
 592               		.loc 1 228 13 is_stmt 0 view .LVU185
 593 0014 832F      		mov r24,r19
 594               	.LVL22:
 229:Caterina.c    ****         p = 254-p;
 595               		.loc 1 229 5 is_stmt 1 view .LVU186
 229:Caterina.c    ****         p = 254-p;
 596               		.loc 1 229 8 is_stmt 0 view .LVU187
 597 0016 37FF      		sbrs r19,7
 598 0018 00C0      		rjmp .L36
 230:Caterina.c    ****     p += p;
 599               		.loc 1 230 9 is_stmt 1 view .LVU188
 230:Caterina.c    ****     p += p;
 600               		.loc 1 230 11 is_stmt 0 view .LVU189
 601 001a 8EEF      		ldi r24,lo8(-2)
 602 001c 831B      		sub r24,r19
 603               	.LVL23:
 604               	.L36:
 231:Caterina.c    ****     if (((uint8_t)LLEDPulse) > p)
 605               		.loc 1 231 5 is_stmt 1 view .LVU190
 232:Caterina.c    ****         L_LED_OFF();
 606               		.loc 1 232 5 view .LVU191
 231:Caterina.c    ****     if (((uint8_t)LLEDPulse) > p)
 607               		.loc 1 231 7 is_stmt 0 view .LVU192
 608 001e 880F      		lsl r24
 609               	.LVL24:
 232:Caterina.c    ****         L_LED_OFF();
 610               		.loc 1 232 8 view .LVU193
 611 0020 8217      		cp r24,r18
 612 0022 00F4      		brsh .L37
 233:Caterina.c    ****     else
 613               		.loc 1 233 9 is_stmt 1 view .LVU194
 614 0024 4798      		cbi 0x8,7
 615 0026 0895      		ret
 616               	.L37:
 235:Caterina.c    **** }
 617               		.loc 1 235 9 view .LVU195
 618 0028 479A      		sbi 0x8,7
 619               	/* epilogue start */
 236:Caterina.c    **** 
 620               		.loc 1 236 1 is_stmt 0 view .LVU196
 621 002a 0895      		ret
 622               		.cfi_endproc
 623               	.LFE107:
 625               		.section	.text.SetupHardware,"ax",@progbits
 626               	.global	SetupHardware
 628               	SetupHardware:
 629               	.LFB109:
 286:Caterina.c    ****     /* Disable clock division */
 630               		.loc 1 286 1 is_stmt 1 view -0
 631               		.cfi_startproc
 632               	/* prologue: function */
 633               	/* frame size = 0 */
 634               	/* stack size = 0 */
 635               	.L__stack_usage = 0
 289:Caterina.c    **** 
 636               		.loc 1 289 5 view .LVU198
 637 0000 E1E6      		ldi r30,lo8(97)
 638 0002 F0E0      		ldi r31,0
 639 0004 80E8      		ldi r24,lo8(-128)
 640 0006 8083      		st Z,r24
 641 0008 1082      		st Z,__zero_reg__
 292:Caterina.c    ****     MCUCR = (1 << IVSEL);
 642               		.loc 1 292 5 view .LVU199
 292:Caterina.c    ****     MCUCR = (1 << IVSEL);
 643               		.loc 1 292 11 is_stmt 0 view .LVU200
 644 000a 81E0      		ldi r24,lo8(1)
 645 000c 85BF      		out 0x35,r24
 293:Caterina.c    **** 
 646               		.loc 1 293 5 is_stmt 1 view .LVU201
 293:Caterina.c    **** 
 647               		.loc 1 293 11 is_stmt 0 view .LVU202
 648 000e 82E0      		ldi r24,lo8(2)
 649 0010 85BF      		out 0x35,r24
 295:Caterina.c    ****     L_LED_OFF();
 650               		.loc 1 295 5 is_stmt 1 view .LVU203
 651 0012 3F9A      		sbi 0x7,7
 295:Caterina.c    ****     L_LED_OFF();
 652               		.loc 1 295 5 view .LVU204
 653 0014 529A      		sbi 0xa,2
 295:Caterina.c    ****     L_LED_OFF();
 654               		.loc 1 295 5 view .LVU205
 655 0016 539A      		sbi 0xa,3
 295:Caterina.c    ****     L_LED_OFF();
 656               		.loc 1 295 16 view .LVU206
 296:Caterina.c    ****     TX_LED_OFF();
 657               		.loc 1 296 5 view .LVU207
 658 0018 4798      		cbi 0x8,7
 297:Caterina.c    ****     RX_LED_OFF();
 659               		.loc 1 297 5 view .LVU208
 660 001a 5B9A      		sbi 0xb,3
 298:Caterina.c    **** 
 661               		.loc 1 298 5 view .LVU209
 662 001c 5A9A      		sbi 0xb,2
 306:Caterina.c    ****     OCR1AL = 250;
 663               		.loc 1 306 5 view .LVU210
 306:Caterina.c    ****     OCR1AL = 250;
 664               		.loc 1 306 12 is_stmt 0 view .LVU211
 665 001e 1092 8900 		sts 137,__zero_reg__
 307:Caterina.c    ****     TIMSK1 = (1 << OCIE1A);					// enable timer 1 output compare A match interrupt
 666               		.loc 1 307 5 is_stmt 1 view .LVU212
 307:Caterina.c    ****     TIMSK1 = (1 << OCIE1A);					// enable timer 1 output compare A match interrupt
 667               		.loc 1 307 12 is_stmt 0 view .LVU213
 668 0022 9AEF      		ldi r25,lo8(-6)
 669 0024 9093 8800 		sts 136,r25
 308:Caterina.c    ****     TCCR1B = ((1 << CS11) | (1 << CS10));	// 1/64 prescaler on timer 1 input
 670               		.loc 1 308 5 is_stmt 1 view .LVU214
 308:Caterina.c    ****     TCCR1B = ((1 << CS11) | (1 << CS10));	// 1/64 prescaler on timer 1 input
 671               		.loc 1 308 12 is_stmt 0 view .LVU215
 672 0028 8093 6F00 		sts 111,r24
 309:Caterina.c    **** 
 673               		.loc 1 309 5 is_stmt 1 view .LVU216
 309:Caterina.c    **** 
 674               		.loc 1 309 12 is_stmt 0 view .LVU217
 675 002c 83E0      		ldi r24,lo8(3)
 676 002e 8093 8100 		sts 129,r24
 312:Caterina.c    **** }
 677               		.loc 1 312 5 is_stmt 1 view .LVU218
 678 0032 0C94 0000 		jmp USB_Init
 679               	.LVL25:
 680               		.cfi_endproc
 681               	.LFE109:
 683               		.section	.text.__vector_17,"ax",@progbits
 684               	.global	__vector_17
 686               	__vector_17:
 687               	.LFB110:
 317:Caterina.c    ****     /* Reset counter */
 688               		.loc 1 317 1 view -0
 689               		.cfi_startproc
 690 0000 1F92 1FB6 		__gcc_isr 1
 690      1F92 1124 
 690      2F93 
 691 000a 8F93      		push r24
 692               	.LCFI0:
 693               		.cfi_def_cfa_offset 3
 694               		.cfi_offset 24, -2
 695 000c 9F93      		push r25
 696               	.LCFI1:
 697               		.cfi_def_cfa_offset 4
 698               		.cfi_offset 25, -3
 699 000e EF93      		push r30
 700               	.LCFI2:
 701               		.cfi_def_cfa_offset 5
 702               		.cfi_offset 30, -4
 703 0010 FF93      		push r31
 704               	.LCFI3:
 705               		.cfi_def_cfa_offset 6
 706               		.cfi_offset 31, -5
 707               	/* prologue: Signal */
 708               	/* frame size = 0 */
 709               	/* stack size = 4...8 */
 710               	.L__stack_usage = 4 + __gcc_isr.n_pushed
 319:Caterina.c    ****     TCNT1L = 0;
 711               		.loc 1 319 5 view .LVU220
 319:Caterina.c    ****     TCNT1L = 0;
 712               		.loc 1 319 12 is_stmt 0 view .LVU221
 713 0012 1092 8500 		sts 133,__zero_reg__
 320:Caterina.c    **** 
 714               		.loc 1 320 5 is_stmt 1 view .LVU222
 320:Caterina.c    **** 
 715               		.loc 1 320 12 is_stmt 0 view .LVU223
 716 0016 1092 8400 		sts 132,__zero_reg__
 323:Caterina.c    ****         TX_LED_OFF();
 717               		.loc 1 323 5 is_stmt 1 view .LVU224
 323:Caterina.c    ****         TX_LED_OFF();
 718               		.loc 1 323 9 is_stmt 0 view .LVU225
 719 001a 8091 0000 		lds r24,TxLEDPulse
 720 001e 9091 0000 		lds r25,TxLEDPulse+1
 323:Caterina.c    ****         TX_LED_OFF();
 721               		.loc 1 323 8 view .LVU226
 722 0022 0097      		sbiw r24,0
 723 0024 01F0      		breq .L42
 323:Caterina.c    ****         TX_LED_OFF();
 724               		.loc 1 323 25 discriminator 1 view .LVU227
 725 0026 0197      		sbiw r24,1
 323:Caterina.c    ****         TX_LED_OFF();
 726               		.loc 1 323 20 discriminator 1 view .LVU228
 727 0028 9093 0000 		sts TxLEDPulse+1,r25
 728 002c 8093 0000 		sts TxLEDPulse,r24
 729 0030 892B      		or r24,r25
 730 0032 01F4      		brne .L42
 324:Caterina.c    ****     if (RxLEDPulse && !(--RxLEDPulse))
 731               		.loc 1 324 9 is_stmt 1 view .LVU229
 732 0034 5B9A      		sbi 0xb,3
 733               	.L42:
 325:Caterina.c    ****         RX_LED_OFF();
 734               		.loc 1 325 5 view .LVU230
 325:Caterina.c    ****         RX_LED_OFF();
 735               		.loc 1 325 9 is_stmt 0 view .LVU231
 736 0036 8091 0000 		lds r24,RxLEDPulse
 737 003a 9091 0000 		lds r25,RxLEDPulse+1
 325:Caterina.c    ****         RX_LED_OFF();
 738               		.loc 1 325 8 view .LVU232
 739 003e 0097      		sbiw r24,0
 740 0040 01F0      		breq .L45
 325:Caterina.c    ****         RX_LED_OFF();
 741               		.loc 1 325 25 discriminator 1 view .LVU233
 742 0042 0197      		sbiw r24,1
 325:Caterina.c    ****         RX_LED_OFF();
 743               		.loc 1 325 20 discriminator 1 view .LVU234
 744 0044 9093 0000 		sts RxLEDPulse+1,r25
 745 0048 8093 0000 		sts RxLEDPulse,r24
 746 004c 892B      		or r24,r25
 747 004e 01F4      		brne .L45
 326:Caterina.c    **** 
 748               		.loc 1 326 9 is_stmt 1 view .LVU235
 749 0050 5A9A      		sbi 0xb,2
 750               	.L45:
 328:Caterina.c    ****         Timeout++;
 751               		.loc 1 328 5 view .LVU236
 752               	.LBB116:
 328:Caterina.c    ****         Timeout++;
 753               		.loc 1 328 9 view .LVU237
 754               	.LVL26:
 328:Caterina.c    ****         Timeout++;
 755               		.loc 1 328 9 view .LVU238
 328:Caterina.c    ****         Timeout++;
 756               		.loc 1 328 9 view .LVU239
 757 0052 F0E0      		ldi r31,0
 758 0054 E0E0      		ldi r30,0
 759               	/* #APP */
 760               	 ;  328 "Caterina.c" 1
 761 0056 8591      		lpm r24, Z+
 762 0058 9491      		lpm r25, Z
 763               		
 764               	 ;  0 "" 2
 765               	.LVL27:
 328:Caterina.c    ****         Timeout++;
 766               		.loc 1 328 9 view .LVU240
 767               	/* #NOAPP */
 768               	.LBE116:
 328:Caterina.c    ****         Timeout++;
 769               		.loc 1 328 8 is_stmt 0 view .LVU241
 770 005a 0196      		adiw r24,1
 771 005c 01F0      		breq .L40
 329:Caterina.c    **** }
 772               		.loc 1 329 9 is_stmt 1 view .LVU242
 329:Caterina.c    **** }
 773               		.loc 1 329 16 is_stmt 0 view .LVU243
 774 005e 8091 0000 		lds r24,Timeout
 775 0062 9091 0000 		lds r25,Timeout+1
 776               	.LVL28:
 329:Caterina.c    **** }
 777               		.loc 1 329 16 view .LVU244
 778 0066 0196      		adiw r24,1
 779 0068 9093 0000 		sts Timeout+1,r25
 780 006c 8093 0000 		sts Timeout,r24
 781               	.L40:
 782               	/* epilogue start */
 330:Caterina.c    **** 
 783               		.loc 1 330 1 view .LVU245
 784 0070 FF91      		pop r31
 785 0072 EF91      		pop r30
 786 0074 9F91      		pop r25
 787 0076 8F91      		pop r24
 788 0078 2F91 1F90 		__gcc_isr 2
 788      1FBE 1F90 
 789 0080 1895      		reti
 790               		__gcc_isr 0,r18
 791               		.cfi_endproc
 792               	.LFE110:
 794               		.section	.text.EVENT_USB_Device_ConfigurationChanged,"ax",@progbits
 795               	.global	EVENT_USB_Device_ConfigurationChanged
 797               	EVENT_USB_Device_ConfigurationChanged:
 798               	.LFB111:
 336:Caterina.c    ****     /* Setup CDC Notification, Rx and Tx Endpoints */
 799               		.loc 1 336 1 is_stmt 1 view -0
 800               		.cfi_startproc
 801               	/* prologue: function */
 802               	/* frame size = 0 */
 803               	/* stack size = 0 */
 804               	.L__stack_usage = 0
 338:Caterina.c    ****                                ENDPOINT_DIR_IN, CDC_NOTIFICATION_EPSIZE,
 805               		.loc 1 338 5 view .LVU247
 806               	.LVL29:
 807               	.LBB117:
 808               	.LBI117:
 270:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			                                              const uint8_t Type,
 809               		.loc 2 270 23 view .LVU248
 810               	.LBB118:
 276:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                      ((1 << ALLOC) | Banks | Endpoint_BytesToEPSizeMask(Size))
 811               		.loc 2 276 5 view .LVU249
 276:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                      ((1 << ALLOC) | Banks | Endpoint_BytesToEPSizeMask(Size))
 812               		.loc 2 276 5 is_stmt 0 view .LVU250
 813               	.LBE118:
 814               	.LBE117:
 126:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				uint16_t CheckBytes = 8;
 815               		.loc 2 126 5 is_stmt 1 view .LVU251
 127:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 816               		.loc 2 127 5 view .LVU252
 129:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				{
 817               		.loc 2 129 5 view .LVU253
 129:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				{
 818               		.loc 2 129 11 view .LVU254
 135:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 819               		.loc 2 135 5 view .LVU255
 820               	.LBB120:
 821               	.LBB119:
 276:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                      ((1 << ALLOC) | Banks | Endpoint_BytesToEPSizeMask(Size))
 822               		.loc 2 276 12 is_stmt 0 view .LVU256
 823 0000 42E0      		ldi r20,lo8(2)
 824 0002 61EC      		ldi r22,lo8(-63)
 825 0004 82E0      		ldi r24,lo8(2)
 826 0006 0E94 0000 		call Endpoint_ConfigureEndpoint_Prv
 827               	.LVL30:
 276:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                      ((1 << ALLOC) | Banks | Endpoint_BytesToEPSizeMask(Size))
 828               		.loc 2 276 12 view .LVU257
 829               	.LBE119:
 830               	.LBE120:
 129:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				{
 831               		.loc 2 129 11 is_stmt 1 view .LVU258
 131:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					CheckBytes <<= 1;
 832               		.loc 2 131 6 view .LVU259
 132:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				}
 833               		.loc 2 132 6 view .LVU260
 129:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				{
 834               		.loc 2 129 11 view .LVU261
 135:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 835               		.loc 2 135 5 view .LVU262
 836               	.LBB121:
 837               	.LBB122:
 276:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                      ((1 << ALLOC) | Banks | Endpoint_BytesToEPSizeMask(Size))
 838               		.loc 2 276 12 is_stmt 0 view .LVU263
 839 000a 42E1      		ldi r20,lo8(18)
 840 000c 61E8      		ldi r22,lo8(-127)
 841 000e 83E0      		ldi r24,lo8(3)
 842 0010 0E94 0000 		call Endpoint_ConfigureEndpoint_Prv
 843               	.LVL31:
 276:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                      ((1 << ALLOC) | Banks | Endpoint_BytesToEPSizeMask(Size))
 844               		.loc 2 276 12 view .LVU264
 845               	.LBE122:
 846               	.LBE121:
 129:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				{
 847               		.loc 2 129 11 is_stmt 1 view .LVU265
 131:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 					CheckBytes <<= 1;
 848               		.loc 2 131 6 view .LVU266
 132:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				}
 849               		.loc 2 132 6 view .LVU267
 129:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				{
 850               		.loc 2 129 11 view .LVU268
 135:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 851               		.loc 2 135 5 view .LVU269
 852               	.LBB123:
 853               	.LBB124:
 276:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				                                      ((1 << ALLOC) | Banks | Endpoint_BytesToEPSizeMask(Size))
 854               		.loc 2 276 12 is_stmt 0 view .LVU270
 855 0014 42E1      		ldi r20,lo8(18)
 856 0016 60E8      		ldi r22,lo8(-128)
 857 0018 84E0      		ldi r24,lo8(4)
 858 001a 0C94 0000 		jmp Endpoint_ConfigureEndpoint_Prv
 859               	.LVL32:
 860               	.LBE124:
 861               	.LBE123:
 862               		.cfi_endproc
 863               	.LFE111:
 865               		.section	.text.EVENT_USB_Device_ControlRequest,"ax",@progbits
 866               	.global	EVENT_USB_Device_ControlRequest
 868               	EVENT_USB_Device_ControlRequest:
 869               	.LFB112:
 356:Caterina.c    ****     /* Ignore any requests that aren't directed to the CDC interface */
 870               		.loc 1 356 1 is_stmt 1 view -0
 871               		.cfi_startproc
 872               	/* prologue: function */
 873               	/* frame size = 0 */
 874               	/* stack size = 0 */
 875               	.L__stack_usage = 0
 358:Caterina.c    ****         (REQTYPE_CLASS | REQREC_INTERFACE))
 876               		.loc 1 358 5 view .LVU272
 358:Caterina.c    ****         (REQTYPE_CLASS | REQREC_INTERFACE))
 877               		.loc 1 358 28 is_stmt 0 view .LVU273
 878 0000 8091 0000 		lds r24,USB_ControlRequest
 358:Caterina.c    ****         (REQTYPE_CLASS | REQREC_INTERFACE))
 879               		.loc 1 358 8 view .LVU274
 880 0004 982F      		mov r25,r24
 881 0006 9F77      		andi r25,lo8(127)
 882 0008 9132      		cpi r25,lo8(33)
 883 000a 01F4      		brne .L52
 365:Caterina.c    ****     {
 884               		.loc 1 365 5 is_stmt 1 view .LVU275
 365:Caterina.c    ****     {
 885               		.loc 1 365 31 is_stmt 0 view .LVU276
 886 000c 9091 0000 		lds r25,USB_ControlRequest+1
 365:Caterina.c    ****     {
 887               		.loc 1 365 5 view .LVU277
 888 0010 9032      		cpi r25,lo8(32)
 889 0012 01F0      		breq .L54
 890 0014 9132      		cpi r25,lo8(33)
 891 0016 01F4      		brne .L52
 368:Caterina.c    ****             {
 892               		.loc 1 368 13 is_stmt 1 view .LVU278
 368:Caterina.c    ****             {
 893               		.loc 1 368 16 is_stmt 0 view .LVU279
 894 0018 813A      		cpi r24,lo8(-95)
 895 001a 01F4      		brne .L52
 370:Caterina.c    **** 
 896               		.loc 1 370 17 is_stmt 1 view .LVU280
 897               	.LBB125:
 898               	.LBI125:
 502:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 899               		.loc 2 502 23 view .LVU281
 900               	.LBB126:
 504:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 901               		.loc 2 504 5 view .LVU282
 504:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 902               		.loc 2 504 12 is_stmt 0 view .LVU283
 903 001c 8091 E800 		lds r24,232
 904 0020 877F      		andi r24,lo8(-9)
 905 0022 8093 E800 		sts 232,r24
 906               	.LBE126:
 907               	.LBE125:
 373:Caterina.c    ****                 Endpoint_ClearOUT();
 908               		.loc 1 373 17 is_stmt 1 view .LVU284
 909 0026 67E0      		ldi r22,lo8(7)
 910 0028 70E0      		ldi r23,0
 911 002a 80E0      		ldi r24,lo8(LineEncoding)
 912 002c 90E0      		ldi r25,hi8(LineEncoding)
 913 002e 0E94 0000 		call Endpoint_Write_Control_Stream_LE
 914               	.LVL33:
 374:Caterina.c    ****             }
 915               		.loc 1 374 17 view .LVU285
 916               	.LBB127:
 917               	.LBI127:
 528:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 918               		.loc 2 528 23 view .LVU286
 919               	.LBB128:
 531:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 920               		.loc 2 531 6 view .LVU287
 531:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 921               		.loc 2 531 13 is_stmt 0 view .LVU288
 922 0032 8091 E800 		lds r24,232
 923 0036 8B77      		andi r24,lo8(123)
 924               	.L55:
 925               	.LBE128:
 926               	.LBE127:
 927               	.LBB129:
 928               	.LBB130:
 516:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 929               		.loc 2 516 13 view .LVU289
 930 0038 8093 E800 		sts 232,r24
 931               	.L52:
 932               	/* epilogue start */
 933               	.LBE130:
 934               	.LBE129:
 390:Caterina.c    **** 
 935               		.loc 1 390 1 view .LVU290
 936 003c 0895      		ret
 937               	.L54:
 379:Caterina.c    ****             {
 938               		.loc 1 379 13 is_stmt 1 view .LVU291
 379:Caterina.c    ****             {
 939               		.loc 1 379 16 is_stmt 0 view .LVU292
 940 003e 8132      		cpi r24,lo8(33)
 941 0040 01F4      		brne .L52
 381:Caterina.c    **** 
 942               		.loc 1 381 17 is_stmt 1 view .LVU293
 943               	.LBB132:
 944               	.LBI132:
 502:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 945               		.loc 2 502 23 view .LVU294
 946               	.LBB133:
 504:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 947               		.loc 2 504 5 view .LVU295
 504:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 948               		.loc 2 504 12 is_stmt 0 view .LVU296
 949 0042 8091 E800 		lds r24,232
 950 0046 877F      		andi r24,lo8(-9)
 951 0048 8093 E800 		sts 232,r24
 952               	.LBE133:
 953               	.LBE132:
 384:Caterina.c    ****                 Endpoint_ClearIN();
 954               		.loc 1 384 17 is_stmt 1 view .LVU297
 955 004c 67E0      		ldi r22,lo8(7)
 956 004e 70E0      		ldi r23,0
 957 0050 80E0      		ldi r24,lo8(LineEncoding)
 958 0052 90E0      		ldi r25,hi8(LineEncoding)
 959 0054 0E94 0000 		call Endpoint_Read_Control_Stream_LE
 960               	.LVL34:
 385:Caterina.c    ****             }
 961               		.loc 1 385 17 view .LVU298
 962               	.LBB134:
 963               	.LBI129:
 513:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 964               		.loc 2 513 23 view .LVU299
 965               	.LBB131:
 516:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 966               		.loc 2 516 6 view .LVU300
 516:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 967               		.loc 2 516 13 is_stmt 0 view .LVU301
 968 0058 8091 E800 		lds r24,232
 969 005c 8E77      		andi r24,lo8(126)
 970 005e 00C0      		rjmp .L55
 971               	.LBE131:
 972               	.LBE134:
 973               		.cfi_endproc
 974               	.LFE112:
 976               		.section	.rodata.str1.1,"aMS",@progbits,1
 977               	.LC0:
 978 0000 4341 5445 		.string	"CATERINA"
 978      5249 4E41 
 978      00
 979               		.section	.text.CDC_Task,"ax",@progbits
 980               	.global	CDC_Task
 982               	CDC_Task:
 983               	.LFB116:
 569:Caterina.c    **** 
 570:Caterina.c    **** #define STK_OK              0x10
 571:Caterina.c    **** #define STK_INSYNC          0x14  // ' '
 572:Caterina.c    **** #define CRC_EOP             0x20  // 'SPACE'
 573:Caterina.c    **** #define STK_GET_SYNC        0x30  // '0'
 574:Caterina.c    **** 
 575:Caterina.c    **** #define STK_GET_PARAMETER   0x41  // 'A'
 576:Caterina.c    **** #define STK_SET_DEVICE      0x42  // 'B'
 577:Caterina.c    **** #define STK_SET_DEVICE_EXT  0x45  // 'E'
 578:Caterina.c    **** #define STK_LOAD_ADDRESS    0x55  // 'U'
 579:Caterina.c    **** #define STK_UNIVERSAL       0x56  // 'V'
 580:Caterina.c    **** #define STK_PROG_PAGE       0x64  // 'd'
 581:Caterina.c    **** #define STK_READ_PAGE       0x74  // 't'
 582:Caterina.c    **** #define STK_READ_SIGN       0x75  // 'u'
 583:Caterina.c    **** 
 584:Caterina.c    **** /** Task to read in AVR910 commands from the CDC data OUT endpoint, process them, perform the requi
 585:Caterina.c    ****  *  and send the appropriate response back to the host.
 586:Caterina.c    ****  */
 587:Caterina.c    **** void CDC_Task(void)
 588:Caterina.c    **** {
 984               		.loc 1 588 1 is_stmt 1 view -0
 985               		.cfi_startproc
 986 0000 4F92      		push r4
 987               	.LCFI4:
 988               		.cfi_def_cfa_offset 3
 989               		.cfi_offset 4, -2
 990 0002 5F92      		push r5
 991               	.LCFI5:
 992               		.cfi_def_cfa_offset 4
 993               		.cfi_offset 5, -3
 994 0004 6F92      		push r6
 995               	.LCFI6:
 996               		.cfi_def_cfa_offset 5
 997               		.cfi_offset 6, -4
 998 0006 7F92      		push r7
 999               	.LCFI7:
 1000               		.cfi_def_cfa_offset 6
 1001               		.cfi_offset 7, -5
 1002 0008 8F92      		push r8
 1003               	.LCFI8:
 1004               		.cfi_def_cfa_offset 7
 1005               		.cfi_offset 8, -6
 1006 000a 9F92      		push r9
 1007               	.LCFI9:
 1008               		.cfi_def_cfa_offset 8
 1009               		.cfi_offset 9, -7
 1010 000c AF92      		push r10
 1011               	.LCFI10:
 1012               		.cfi_def_cfa_offset 9
 1013               		.cfi_offset 10, -8
 1014 000e BF92      		push r11
 1015               	.LCFI11:
 1016               		.cfi_def_cfa_offset 10
 1017               		.cfi_offset 11, -9
 1018 0010 CF92      		push r12
 1019               	.LCFI12:
 1020               		.cfi_def_cfa_offset 11
 1021               		.cfi_offset 12, -10
 1022 0012 DF92      		push r13
 1023               	.LCFI13:
 1024               		.cfi_def_cfa_offset 12
 1025               		.cfi_offset 13, -11
 1026 0014 EF92      		push r14
 1027               	.LCFI14:
 1028               		.cfi_def_cfa_offset 13
 1029               		.cfi_offset 14, -12
 1030 0016 FF92      		push r15
 1031               	.LCFI15:
 1032               		.cfi_def_cfa_offset 14
 1033               		.cfi_offset 15, -13
 1034 0018 0F93      		push r16
 1035               	.LCFI16:
 1036               		.cfi_def_cfa_offset 15
 1037               		.cfi_offset 16, -14
 1038 001a 1F93      		push r17
 1039               	.LCFI17:
 1040               		.cfi_def_cfa_offset 16
 1041               		.cfi_offset 17, -15
 1042 001c CF93      		push r28
 1043               	.LCFI18:
 1044               		.cfi_def_cfa_offset 17
 1045               		.cfi_offset 28, -16
 1046 001e DF93      		push r29
 1047               	.LCFI19:
 1048               		.cfi_def_cfa_offset 18
 1049               		.cfi_offset 29, -17
 1050               	/* prologue: function */
 1051               	/* frame size = 0 */
 1052               	/* stack size = 16 */
 1053               	.L__stack_usage = 16
 589:Caterina.c    ****     /* Select the OUT endpoint */
 590:Caterina.c    ****     Endpoint_SelectEndpoint(CDC_RX_EPNUM);
 1054               		.loc 1 590 5 view .LVU303
 1055               	.LVL35:
 1056               	.LBB167:
 1057               	.LBI167:
 327:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 1058               		.loc 2 327 23 view .LVU304
 1059               	.LBB168:
 330:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 1060               		.loc 2 330 6 view .LVU305
 330:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 1061               		.loc 2 330 12 is_stmt 0 view .LVU306
 1062 0020 84E0      		ldi r24,lo8(4)
 1063 0022 8093 E900 		sts 233,r24
 1064               	.LVL36:
 330:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 1065               		.loc 2 330 12 view .LVU307
 1066               	.LBE168:
 1067               	.LBE167:
 591:Caterina.c    **** 
 592:Caterina.c    ****     /* Check if endpoint has a command in it sent from the host */
 593:Caterina.c    ****     if (!(Endpoint_IsOUTReceived()))
 1068               		.loc 1 593 5 is_stmt 1 view .LVU308
 1069               	.LBB169:
 1070               	.LBI169:
 477:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 1071               		.loc 2 477 23 view .LVU309
 1072               	.LBB170:
 479:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 1073               		.loc 2 479 5 view .LVU310
 479:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 1074               		.loc 2 479 14 is_stmt 0 view .LVU311
 1075 0026 8091 E800 		lds r24,232
 1076               	.LBE170:
 1077               	.LBE169:
 1078               		.loc 1 593 8 view .LVU312
 1079 002a 82FF      		sbrs r24,2
 1080 002c 00C0      		rjmp .L56
 594:Caterina.c    ****       return;
 595:Caterina.c    **** 
 596:Caterina.c    ****     RX_LED_ON();
 1081               		.loc 1 596 5 is_stmt 1 view .LVU313
 1082 002e 5A98      		cbi 0xb,2
 597:Caterina.c    ****     RxLEDPulse = TX_RX_LED_PULSE_PERIOD;
 1083               		.loc 1 597 5 view .LVU314
 1084               		.loc 1 597 16 is_stmt 0 view .LVU315
 1085 0030 84E6      		ldi r24,lo8(100)
 1086 0032 90E0      		ldi r25,0
 1087 0034 9093 0000 		sts RxLEDPulse+1,r25
 1088 0038 8093 0000 		sts RxLEDPulse,r24
 598:Caterina.c    **** 
 599:Caterina.c    ****     /* Read in the bootloader command (first byte sent from host) */
 600:Caterina.c    ****     uint8_t Command = FetchNextCommandByte();
 1089               		.loc 1 600 5 is_stmt 1 view .LVU316
 1090               		.loc 1 600 23 is_stmt 0 view .LVU317
 1091 003c 0E94 0000 		call FetchNextCommandByte
 1092               	.LVL37:
 1093 0040 C82F      		mov r28,r24
 1094               	.LVL38:
 601:Caterina.c    **** 
 602:Caterina.c    ****     if (Command == 'E')
 1095               		.loc 1 602 5 is_stmt 1 view .LVU318
 1096               		.loc 1 602 8 is_stmt 0 view .LVU319
 1097 0042 8534      		cpi r24,lo8(69)
 1098 0044 01F4      		brne .L59
 603:Caterina.c    ****     {
 604:Caterina.c    ****         /* We nearly run out the bootloader timeout clock,
 605:Caterina.c    ****         * leaving just a few hundred milliseconds so the
 606:Caterina.c    ****         * bootloder has time to respond and service any
 607:Caterina.c    ****         * subsequent requests */
 608:Caterina.c    ****         Timeout = TIMEOUT_PERIOD - 500;
 1099               		.loc 1 608 9 is_stmt 1 view .LVU320
 1100               		.loc 1 608 17 is_stmt 0 view .LVU321
 1101 0046 84EF      		ldi r24,lo8(-12)
 1102 0048 9FEF      		ldi r25,lo8(-1)
 1103               	.LVL39:
 1104               		.loc 1 608 17 view .LVU322
 1105 004a 9093 0000 		sts Timeout+1,r25
 1106 004e 8093 0000 		sts Timeout,r24
 1107               	.L60:
 609:Caterina.c    **** 
 610:Caterina.c    ****         /* Re-enable RWW section - must be done here in case
 611:Caterina.c    ****          * user has disabled verification on upload.  */
 612:Caterina.c    ****         boot_rww_enable_safe();
 1108               		.loc 1 612 9 is_stmt 1 discriminator 1 view .LVU323
 1109               		.loc 1 612 9 discriminator 1 view .LVU324
 1110               		.loc 1 612 9 discriminator 1 view .LVU325
 1111               		.loc 1 612 9 discriminator 1 view .LVU326
 1112 0052 07B6      		in __tmp_reg__,0x37
 1113 0054 00FC      		sbrc __tmp_reg__,0
 1114 0056 00C0      		rjmp .L60
 1115               	.L61:
 1116               		.loc 1 612 9 discriminator 3 view .LVU327
 1117               		.loc 1 612 9 discriminator 3 view .LVU328
 1118               		.loc 1 612 9 discriminator 3 view .LVU329
 1119 0058 F999      		sbic 0x1f,1
 1120 005a 00C0      		rjmp .L61
 1121               		.loc 1 612 9 discriminator 4 view .LVU330
 1122 005c 81E1      		ldi r24,lo8(17)
 1123               	/* #APP */
 1124               	 ;  612 "Caterina.c" 1
 1125 005e 8093 5700 		sts 87, r24
 1126 0062 E895      		spm
 1127               		
 1128               	 ;  0 "" 2
 1129               		.loc 1 612 9 discriminator 4 view .LVU331
 613:Caterina.c    **** 
 614:Caterina.c    ****         // Send confirmation byte back to the host
 615:Caterina.c    ****         WriteNextResponseByte('\r');
 1130               		.loc 1 615 9 discriminator 4 view .LVU332
 1131               	.LVL40:
 1132               	/* #NOAPP */
 1133               	.L145:
 616:Caterina.c    ****     }
 617:Caterina.c    ****     else if (Command == 'T')
 618:Caterina.c    ****     {
 619:Caterina.c    ****         FetchNextCommandByte();
 620:Caterina.c    **** 
 621:Caterina.c    ****         // Send confirmation byte back to the host
 622:Caterina.c    ****         WriteNextResponseByte('\r');
 1134               		.loc 1 622 9 view .LVU333
 1135 0064 8DE0      		ldi r24,lo8(13)
 1136               	.L146:
 1137 0066 0E94 0000 		call WriteNextResponseByte
 1138               	.LVL41:
 1139               	.L62:
 623:Caterina.c    ****     }
 624:Caterina.c    ****     else if ((Command == 'L') || (Command == 'P'))
 625:Caterina.c    ****     {
 626:Caterina.c    ****         // Send confirmation byte back to the host
 627:Caterina.c    ****         WriteNextResponseByte('\r');
 628:Caterina.c    ****     }
 629:Caterina.c    ****     else if (Command == 't')
 630:Caterina.c    ****     {
 631:Caterina.c    ****         // Return ATMEGA128 part code - this is only to allow AVRProg to use the bootloader
 632:Caterina.c    ****         WriteNextResponseByte(0x44);
 633:Caterina.c    ****         WriteNextResponseByte(0x00);
 634:Caterina.c    ****     }
 635:Caterina.c    ****     else if (Command == 'a')
 636:Caterina.c    ****     {
 637:Caterina.c    ****         // Indicate auto-address increment is supported
 638:Caterina.c    ****         WriteNextResponseByte('Y');
 639:Caterina.c    ****     }
 640:Caterina.c    ****     else if (Command == 'A')
 641:Caterina.c    ****     {
 642:Caterina.c    ****         // Set the current address to that given by the host
 643:Caterina.c    ****         CurrAddress   = (FetchNextCommandByte() << 9);
 644:Caterina.c    ****         CurrAddress  |= (FetchNextCommandByte() << 1);
 645:Caterina.c    **** 
 646:Caterina.c    ****         // Send confirmation byte back to the host
 647:Caterina.c    ****         WriteNextResponseByte('\r');
 648:Caterina.c    ****     }
 649:Caterina.c    ****     else if (Command == 'p')
 650:Caterina.c    ****     {
 651:Caterina.c    ****         // Indicate serial programmer back to the host
 652:Caterina.c    ****         WriteNextResponseByte('S');
 653:Caterina.c    ****     }
 654:Caterina.c    ****     else if (Command == 'S')
 655:Caterina.c    ****     {
 656:Caterina.c    ****         // Write the 7-byte software identifier to the endpoint
 657:Caterina.c    ****         for (uint8_t CurrByte = 0; CurrByte < 7; CurrByte++)
 658:Caterina.c    ****           WriteNextResponseByte(SOFTWARE_IDENTIFIER[CurrByte]);
 659:Caterina.c    ****     }
 660:Caterina.c    ****     else if (Command == 'V')
 661:Caterina.c    ****     {
 662:Caterina.c    ****         WriteNextResponseByte('0' + BOOTLOADER_VERSION_MAJOR);
 663:Caterina.c    ****         WriteNextResponseByte('0' + BOOTLOADER_VERSION_MINOR);
 664:Caterina.c    ****     }
 665:Caterina.c    ****     else if (Command == 's')
 666:Caterina.c    ****     {
 667:Caterina.c    ****         WriteNextResponseByte(AVR_SIGNATURE_3);
 668:Caterina.c    ****         WriteNextResponseByte(AVR_SIGNATURE_2);
 669:Caterina.c    ****         WriteNextResponseByte(AVR_SIGNATURE_1);
 670:Caterina.c    ****     }
 671:Caterina.c    ****     else if (Command == 'e')
 672:Caterina.c    ****     {
 673:Caterina.c    ****         // Clear the application section of flash
 674:Caterina.c    ****         for (uint32_t CurrFlashAddress = 0; CurrFlashAddress < BOOT_START_ADDR; CurrFlashAddress +=
 675:Caterina.c    ****         {
 676:Caterina.c    ****             boot_page_erase(CurrFlashAddress);
 677:Caterina.c    ****             boot_spm_busy_wait();
 678:Caterina.c    ****             boot_page_write(CurrFlashAddress);
 679:Caterina.c    ****             boot_spm_busy_wait();
 680:Caterina.c    ****         }
 681:Caterina.c    **** 
 682:Caterina.c    ****         // Send confirmation byte back to the host
 683:Caterina.c    ****         WriteNextResponseByte('\r');
 684:Caterina.c    ****     }
 685:Caterina.c    ****     #if !defined(NO_LOCK_BYTE_WRITE_SUPPORT)
 686:Caterina.c    ****     else if (Command == 'l')
 687:Caterina.c    ****     {
 688:Caterina.c    ****         // Set the lock bits to those given by the host
 689:Caterina.c    ****         boot_lock_bits_set(FetchNextCommandByte());
 690:Caterina.c    **** 
 691:Caterina.c    ****         // Send confirmation byte back to the host
 692:Caterina.c    ****         WriteNextResponseByte('\r');
 693:Caterina.c    ****     }
 694:Caterina.c    ****     #endif
 695:Caterina.c    ****     else if (Command == 'r')
 696:Caterina.c    ****     {
 697:Caterina.c    ****         WriteNextResponseByte(boot_lock_fuse_bits_get(GET_LOCK_BITS));
 698:Caterina.c    ****     }
 699:Caterina.c    ****     else if (Command == 'F')
 700:Caterina.c    ****     {
 701:Caterina.c    ****         WriteNextResponseByte(boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS));
 702:Caterina.c    ****     }
 703:Caterina.c    ****     else if (Command == 'N')
 704:Caterina.c    ****     {
 705:Caterina.c    ****         WriteNextResponseByte(boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS));
 706:Caterina.c    ****     }
 707:Caterina.c    ****     else if (Command == 'Q')
 708:Caterina.c    ****     {
 709:Caterina.c    ****         WriteNextResponseByte(boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS));
 710:Caterina.c    ****     }
 711:Caterina.c    ****     #if !defined(NO_BLOCK_SUPPORT)
 712:Caterina.c    ****     else if (Command == 'b')
 713:Caterina.c    ****     {
 714:Caterina.c    ****         WriteNextResponseByte('Y');
 715:Caterina.c    **** 
 716:Caterina.c    ****         // Send block size to the host
 717:Caterina.c    ****         WriteNextResponseByte(SPM_PAGESIZE >> 8);
 718:Caterina.c    ****         WriteNextResponseByte(SPM_PAGESIZE & 0xFF);
 719:Caterina.c    ****     }
 720:Caterina.c    ****     else if ((Command == 'B') || (Command == 'g'))
 721:Caterina.c    ****     {
 722:Caterina.c    ****         // Keep resetting the timeout counter if we're receiving self-programming instructions
 723:Caterina.c    ****         Timeout = 0;
 724:Caterina.c    ****         // Delegate the block write/read to a separate function for clarity
 725:Caterina.c    ****         ReadWriteMemoryBlock(Command);
 726:Caterina.c    ****     }
 727:Caterina.c    ****     #endif
 728:Caterina.c    ****     #if !defined(NO_FLASH_BYTE_SUPPORT)
 729:Caterina.c    ****     else if (Command == 'C')
 730:Caterina.c    ****     {
 731:Caterina.c    ****         // Write the high byte to the current flash page
 732:Caterina.c    ****         boot_page_fill(CurrAddress, FetchNextCommandByte());
 733:Caterina.c    **** 
 734:Caterina.c    ****         // Send confirmation byte back to the host
 735:Caterina.c    ****         WriteNextResponseByte('\r');
 736:Caterina.c    ****     }
 737:Caterina.c    ****     else if (Command == 'c')
 738:Caterina.c    ****     {
 739:Caterina.c    ****         // Write the low byte to the current flash page
 740:Caterina.c    ****         boot_page_fill(CurrAddress | 0x01, FetchNextCommandByte());
 741:Caterina.c    **** 
 742:Caterina.c    ****         // Increment the address
 743:Caterina.c    ****         CurrAddress += 2;
 744:Caterina.c    **** 
 745:Caterina.c    ****         // Send confirmation byte back to the host
 746:Caterina.c    ****         WriteNextResponseByte('\r');
 747:Caterina.c    ****     }
 748:Caterina.c    ****     else if (Command == 'm')
 749:Caterina.c    ****     {
 750:Caterina.c    ****         // Commit the flash page to memory
 751:Caterina.c    ****         boot_page_write(CurrAddress);
 752:Caterina.c    **** 
 753:Caterina.c    ****         // Wait until write operation has completed
 754:Caterina.c    ****         boot_spm_busy_wait();
 755:Caterina.c    **** 
 756:Caterina.c    ****         // Send confirmation byte back to the host
 757:Caterina.c    ****         WriteNextResponseByte('\r');
 758:Caterina.c    ****     }
 759:Caterina.c    ****     else if (Command == 'R')
 760:Caterina.c    ****     {
 761:Caterina.c    ****         #if (FLASHEND > 0xFFFF)
 762:Caterina.c    ****         uint16_t ProgramWord = pgm_read_word_far(CurrAddress);
 763:Caterina.c    ****         #else
 764:Caterina.c    ****         uint16_t ProgramWord = pgm_read_word(CurrAddress);
 765:Caterina.c    ****         #endif
 766:Caterina.c    **** 
 767:Caterina.c    ****         WriteNextResponseByte(ProgramWord >> 8);
 768:Caterina.c    ****         WriteNextResponseByte(ProgramWord & 0xFF);
 769:Caterina.c    ****     }
 770:Caterina.c    ****     #endif
 771:Caterina.c    ****     #if !defined(NO_EEPROM_BYTE_SUPPORT)
 772:Caterina.c    ****     else if (Command == 'D')
 773:Caterina.c    ****     {
 774:Caterina.c    ****         // Read the byte from the endpoint and write it to the EEPROM
 775:Caterina.c    ****         eeprom_write_byte((uint8_t*)((intptr_t)(CurrAddress >> 1)), FetchNextCommandByte());
 776:Caterina.c    **** 
 777:Caterina.c    ****         // Increment the address after use
 778:Caterina.c    ****         CurrAddress += 2;
 779:Caterina.c    **** 
 780:Caterina.c    ****         // Send confirmation byte back to the host
 781:Caterina.c    ****         WriteNextResponseByte('\r');
 782:Caterina.c    ****     }
 783:Caterina.c    ****     else if (Command == 'd')
 784:Caterina.c    ****     {
 785:Caterina.c    ****         // Read the EEPROM byte and write it to the endpoint
 786:Caterina.c    ****         WriteNextResponseByte(eeprom_read_byte((uint8_t*)((intptr_t)(CurrAddress >> 1))));
 787:Caterina.c    **** 
 788:Caterina.c    ****         // Increment the address after use
 789:Caterina.c    ****         CurrAddress += 2;
 790:Caterina.c    ****     }
 791:Caterina.c    **** #endif
 792:Caterina.c    ****     else if (Command != 27)
 793:Caterina.c    ****     {
 794:Caterina.c    ****         // Unknown (non-sync) command, return fail code
 795:Caterina.c    ****         WriteNextResponseByte('?');
 796:Caterina.c    ****     }
 797:Caterina.c    **** 
 798:Caterina.c    **** 
 799:Caterina.c    ****     /* Select the IN endpoint */
 800:Caterina.c    ****     Endpoint_SelectEndpoint(CDC_TX_EPNUM);
 1140               		.loc 1 800 5 view .LVU334
 1141               	.LBB171:
 1142               	.LBI171:
 327:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 1143               		.loc 2 327 23 view .LVU335
 1144               	.LBB172:
 330:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 1145               		.loc 2 330 6 view .LVU336
 330:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 1146               		.loc 2 330 12 is_stmt 0 view .LVU337
 1147 006a 83E0      		ldi r24,lo8(3)
 1148 006c 8093 E900 		sts 233,r24
 1149               	.LVL42:
 330:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 1150               		.loc 2 330 12 view .LVU338
 1151               	.LBE172:
 1152               	.LBE171:
 801:Caterina.c    **** 
 802:Caterina.c    ****     /* Remember if the endpoint is completely full before clearing it */
 803:Caterina.c    ****     bool IsEndpointFull = !(Endpoint_IsReadWriteAllowed());
 1153               		.loc 1 803 5 is_stmt 1 view .LVU339
 1154               	.LBB173:
 1155               	.LBI173:
 418:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 1156               		.loc 2 418 23 view .LVU340
 1157               	.LBB174:
 420:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 1158               		.loc 2 420 5 view .LVU341
 420:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 1159               		.loc 2 420 14 is_stmt 0 view .LVU342
 1160 0070 9091 E800 		lds r25,232
 1161               	.LVL43:
 420:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 1162               		.loc 2 420 14 view .LVU343
 1163               	.LBE174:
 1164               	.LBE173:
 804:Caterina.c    **** 
 805:Caterina.c    ****     /* Send the endpoint data to the host */
 806:Caterina.c    ****     Endpoint_ClearIN();
 1165               		.loc 1 806 5 is_stmt 1 view .LVU344
 1166               	.LBB175:
 1167               	.LBI175:
 513:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 1168               		.loc 2 513 23 view .LVU345
 1169               	.LBB176:
 516:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 1170               		.loc 2 516 6 view .LVU346
 516:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 1171               		.loc 2 516 13 is_stmt 0 view .LVU347
 1172 0074 8091 E800 		lds r24,232
 1173 0078 8E77      		andi r24,lo8(126)
 1174 007a 8093 E800 		sts 232,r24
 1175               	.LBE176:
 1176               	.LBE175:
 807:Caterina.c    **** 
 808:Caterina.c    ****     /* If a full endpoint's worth of data was sent, we need to send an empty packet afterwards to s
 809:Caterina.c    ****     if (IsEndpointFull)
 1177               		.loc 1 809 5 is_stmt 1 view .LVU348
 1178               		.loc 1 809 8 is_stmt 0 view .LVU349
 1179 007e 95FF      		sbrs r25,5
 1180 0080 00C0      		rjmp .L111
 1181               	.L115:
 810:Caterina.c    ****     {
 811:Caterina.c    ****         while (!(Endpoint_IsINReady()))
 812:Caterina.c    ****         {
 813:Caterina.c    ****             if (USB_DeviceState == DEVICE_STATE_Unattached)
 814:Caterina.c    ****               return;
 815:Caterina.c    ****         }
 816:Caterina.c    **** 
 817:Caterina.c    ****         Endpoint_ClearIN();
 818:Caterina.c    ****     }
 819:Caterina.c    **** 
 820:Caterina.c    ****     /* Wait until the data has been sent to the host */
 821:Caterina.c    ****     while (!(Endpoint_IsINReady()))
 1182               		.loc 1 821 11 is_stmt 1 view .LVU350
 1183               	.LBB177:
 1184               	.LBI177:
 465:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 1185               		.loc 2 465 23 view .LVU351
 1186               	.LBB178:
 467:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 1187               		.loc 2 467 5 view .LVU352
 467:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 1188               		.loc 2 467 14 is_stmt 0 view .LVU353
 1189 0082 8091 E800 		lds r24,232
 1190               	.LBE178:
 1191               	.LBE177:
 1192               		.loc 1 821 11 view .LVU354
 1193 0086 80FF      		sbrs r24,0
 1194 0088 00C0      		rjmp .L116
 822:Caterina.c    ****     {
 823:Caterina.c    ****         if (USB_DeviceState == DEVICE_STATE_Unattached)
 824:Caterina.c    ****           return;
 825:Caterina.c    ****     }
 826:Caterina.c    **** 
 827:Caterina.c    ****     /* Select the OUT endpoint */
 828:Caterina.c    ****     Endpoint_SelectEndpoint(CDC_RX_EPNUM);
 1195               		.loc 1 828 5 is_stmt 1 view .LVU355
 1196               	.LVL44:
 1197               	.LBB179:
 1198               	.LBI179:
 327:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 1199               		.loc 2 327 23 view .LVU356
 1200               	.LBB180:
 330:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 1201               		.loc 2 330 6 view .LVU357
 330:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 1202               		.loc 2 330 12 is_stmt 0 view .LVU358
 1203 008a 84E0      		ldi r24,lo8(4)
 1204 008c 8093 E900 		sts 233,r24
 1205               	.LVL45:
 330:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#endif
 1206               		.loc 2 330 12 view .LVU359
 1207               	.LBE180:
 1208               	.LBE179:
 829:Caterina.c    **** 
 830:Caterina.c    ****     /* Acknowledge the command from the host */
 831:Caterina.c    ****     Endpoint_ClearOUT();
 1209               		.loc 1 831 5 is_stmt 1 view .LVU360
 1210               	.LBB181:
 1211               	.LBI181:
 528:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 1212               		.loc 2 528 23 view .LVU361
 1213               	.LBB182:
 531:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 1214               		.loc 2 531 6 view .LVU362
 531:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 1215               		.loc 2 531 13 is_stmt 0 view .LVU363
 1216 0090 8091 E800 		lds r24,232
 1217 0094 8B77      		andi r24,lo8(123)
 1218 0096 8093 E800 		sts 232,r24
 535:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 1219               		.loc 2 535 4 view .LVU364
 1220 009a 00C0      		rjmp .L56
 1221               	.LVL46:
 1222               	.L59:
 535:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 1223               		.loc 2 535 4 view .LVU365
 1224               	.LBE182:
 1225               	.LBE181:
 617:Caterina.c    ****     {
 1226               		.loc 1 617 10 is_stmt 1 view .LVU366
 617:Caterina.c    ****     {
 1227               		.loc 1 617 13 is_stmt 0 view .LVU367
 1228 009c 8435      		cpi r24,lo8(84)
 1229 009e 01F4      		brne .L63
 619:Caterina.c    **** 
 1230               		.loc 1 619 9 is_stmt 1 view .LVU368
 1231 00a0 0E94 0000 		call FetchNextCommandByte
 1232               	.LVL47:
 619:Caterina.c    **** 
 1233               		.loc 1 619 9 is_stmt 0 view .LVU369
 1234 00a4 00C0      		rjmp .L145
 1235               	.LVL48:
 1236               	.L63:
 624:Caterina.c    ****     {
 1237               		.loc 1 624 10 is_stmt 1 view .LVU370
 624:Caterina.c    ****     {
 1238               		.loc 1 624 13 is_stmt 0 view .LVU371
 1239 00a6 8C34      		cpi r24,lo8(76)
 1240 00a8 01F0      		breq .L145
 624:Caterina.c    ****     {
 1241               		.loc 1 624 31 discriminator 1 view .LVU372
 1242 00aa 8035      		cpi r24,lo8(80)
 1243 00ac 01F0      		breq .L145
 629:Caterina.c    ****     {
 1244               		.loc 1 629 10 is_stmt 1 view .LVU373
 629:Caterina.c    ****     {
 1245               		.loc 1 629 13 is_stmt 0 view .LVU374
 1246 00ae 8437      		cpi r24,lo8(116)
 1247 00b0 01F4      		brne .L66
 632:Caterina.c    ****         WriteNextResponseByte(0x00);
 1248               		.loc 1 632 9 is_stmt 1 view .LVU375
 1249 00b2 84E4      		ldi r24,lo8(68)
 1250               	.LVL49:
 632:Caterina.c    ****         WriteNextResponseByte(0x00);
 1251               		.loc 1 632 9 is_stmt 0 view .LVU376
 1252 00b4 0E94 0000 		call WriteNextResponseByte
 1253               	.LVL50:
 633:Caterina.c    ****     }
 1254               		.loc 1 633 9 is_stmt 1 view .LVU377
 1255 00b8 80E0      		ldi r24,0
 1256 00ba 00C0      		rjmp .L146
 1257               	.LVL51:
 1258               	.L66:
 635:Caterina.c    ****     {
 1259               		.loc 1 635 10 view .LVU378
 638:Caterina.c    ****     }
 1260               		.loc 1 638 9 is_stmt 0 view .LVU379
 1261 00bc 89E5      		ldi r24,lo8(89)
 1262               	.LVL52:
 635:Caterina.c    ****     {
 1263               		.loc 1 635 13 view .LVU380
 1264 00be C136      		cpi r28,lo8(97)
 1265 00c0 01F0      		breq .L146
 640:Caterina.c    ****     {
 1266               		.loc 1 640 10 is_stmt 1 view .LVU381
 640:Caterina.c    ****     {
 1267               		.loc 1 640 13 is_stmt 0 view .LVU382
 1268 00c2 C134      		cpi r28,lo8(65)
 1269 00c4 01F4      		brne .L68
 643:Caterina.c    ****         CurrAddress  |= (FetchNextCommandByte() << 1);
 1270               		.loc 1 643 9 is_stmt 1 view .LVU383
 643:Caterina.c    ****         CurrAddress  |= (FetchNextCommandByte() << 1);
 1271               		.loc 1 643 26 is_stmt 0 view .LVU384
 1272 00c6 0E94 0000 		call FetchNextCommandByte
 1273               	.LVL53:
 1274 00ca C82F      		mov r28,r24
 1275               	.LVL54:
 644:Caterina.c    **** 
 1276               		.loc 1 644 9 is_stmt 1 view .LVU385
 644:Caterina.c    **** 
 1277               		.loc 1 644 26 is_stmt 0 view .LVU386
 1278 00cc 0E94 0000 		call FetchNextCommandByte
 1279               	.LVL55:
 643:Caterina.c    ****         CurrAddress  |= (FetchNextCommandByte() << 1);
 1280               		.loc 1 643 26 view .LVU387
 1281 00d0 2C2F      		mov r18,r28
 1282 00d2 30E0      		ldi r19,0
 643:Caterina.c    ****         CurrAddress  |= (FetchNextCommandByte() << 1);
 1283               		.loc 1 643 49 view .LVU388
 1284 00d4 322F      		mov r19,r18
 1285 00d6 2227      		clr r18
 1286 00d8 330F      		lsl r19
 644:Caterina.c    **** 
 1287               		.loc 1 644 26 view .LVU389
 1288 00da 90E0      		ldi r25,0
 644:Caterina.c    **** 
 1289               		.loc 1 644 49 view .LVU390
 1290 00dc 880F      		lsl r24
 1291 00de 991F      		rol r25
 644:Caterina.c    **** 
 1292               		.loc 1 644 22 view .LVU391
 1293 00e0 822B      		or r24,r18
 1294 00e2 932B      		or r25,r19
 1295 00e4 092E      		mov __tmp_reg__,r25
 1296 00e6 000C      		lsl r0
 1297 00e8 AA0B      		sbc r26,r26
 1298 00ea BB0B      		sbc r27,r27
 1299               	.L147:
 778:Caterina.c    **** 
 1300               		.loc 1 778 21 view .LVU392
 1301 00ec 8093 0000 		sts CurrAddress,r24
 1302 00f0 9093 0000 		sts CurrAddress+1,r25
 1303 00f4 A093 0000 		sts CurrAddress+2,r26
 1304 00f8 B093 0000 		sts CurrAddress+3,r27
 781:Caterina.c    ****     }
 1305               		.loc 1 781 9 is_stmt 1 view .LVU393
 1306 00fc 00C0      		rjmp .L145
 1307               	.LVL56:
 1308               	.L68:
 649:Caterina.c    ****     {
 1309               		.loc 1 649 10 view .LVU394
 652:Caterina.c    ****     }
 1310               		.loc 1 652 9 is_stmt 0 view .LVU395
 1311 00fe 83E5      		ldi r24,lo8(83)
 649:Caterina.c    ****     {
 1312               		.loc 1 649 13 view .LVU396
 1313 0100 C037      		cpi r28,lo8(112)
 1314 0102 01F4      		brne .+2
 1315 0104 00C0      		rjmp .L146
 654:Caterina.c    ****     {
 1316               		.loc 1 654 10 is_stmt 1 view .LVU397
 654:Caterina.c    ****     {
 1317               		.loc 1 654 13 is_stmt 0 view .LVU398
 1318 0106 C335      		cpi r28,lo8(83)
 1319 0108 01F4      		brne .L70
 1320 010a C0E0      		ldi r28,lo8(.LC0)
 1321 010c D0E0      		ldi r29,hi8(.LC0)
 1322               	.LVL57:
 1323               	.L71:
 1324               	.LBB183:
 658:Caterina.c    ****     }
 1325               		.loc 1 658 11 is_stmt 1 discriminator 3 view .LVU399
 1326 010e 8991      		ld r24,Y+
 1327               	.LVL58:
 658:Caterina.c    ****     }
 1328               		.loc 1 658 11 is_stmt 0 discriminator 3 view .LVU400
 1329 0110 0E94 0000 		call WriteNextResponseByte
 1330               	.LVL59:
 657:Caterina.c    ****           WriteNextResponseByte(SOFTWARE_IDENTIFIER[CurrByte]);
 1331               		.loc 1 657 50 is_stmt 1 discriminator 3 view .LVU401
 657:Caterina.c    ****           WriteNextResponseByte(SOFTWARE_IDENTIFIER[CurrByte]);
 1332               		.loc 1 657 36 discriminator 3 view .LVU402
 657:Caterina.c    ****           WriteNextResponseByte(SOFTWARE_IDENTIFIER[CurrByte]);
 1333               		.loc 1 657 9 is_stmt 0 discriminator 3 view .LVU403
 1334 0114 20E0      		ldi r18,hi8(.LC0+7)
 1335 0116 C030      		cpi r28,lo8(.LC0+7)
 1336 0118 D207      		cpc r29,r18
 1337 011a 01F4      		brne .L71
 1338 011c 00C0      		rjmp .L62
 1339               	.LVL60:
 1340               	.L70:
 657:Caterina.c    ****           WriteNextResponseByte(SOFTWARE_IDENTIFIER[CurrByte]);
 1341               		.loc 1 657 9 discriminator 3 view .LVU404
 1342               	.LBE183:
 660:Caterina.c    ****     {
 1343               		.loc 1 660 10 is_stmt 1 view .LVU405
 660:Caterina.c    ****     {
 1344               		.loc 1 660 13 is_stmt 0 view .LVU406
 1345 011e C635      		cpi r28,lo8(86)
 1346 0120 01F4      		brne .L72
 662:Caterina.c    ****         WriteNextResponseByte('0' + BOOTLOADER_VERSION_MINOR);
 1347               		.loc 1 662 9 is_stmt 1 view .LVU407
 1348 0122 81E3      		ldi r24,lo8(49)
 1349 0124 0E94 0000 		call WriteNextResponseByte
 1350               	.LVL61:
 663:Caterina.c    ****     }
 1351               		.loc 1 663 9 view .LVU408
 1352 0128 80E3      		ldi r24,lo8(48)
 1353 012a 00C0      		rjmp .L146
 1354               	.L72:
 665:Caterina.c    ****     {
 1355               		.loc 1 665 10 view .LVU409
 665:Caterina.c    ****     {
 1356               		.loc 1 665 13 is_stmt 0 view .LVU410
 1357 012c C337      		cpi r28,lo8(115)
 1358 012e 01F4      		brne .L73
 667:Caterina.c    ****         WriteNextResponseByte(AVR_SIGNATURE_2);
 1359               		.loc 1 667 9 is_stmt 1 view .LVU411
 1360 0130 87E8      		ldi r24,lo8(-121)
 1361 0132 0E94 0000 		call WriteNextResponseByte
 1362               	.LVL62:
 668:Caterina.c    ****         WriteNextResponseByte(AVR_SIGNATURE_1);
 1363               		.loc 1 668 9 view .LVU412
 1364 0136 85E9      		ldi r24,lo8(-107)
 1365 0138 0E94 0000 		call WriteNextResponseByte
 1366               	.LVL63:
 669:Caterina.c    ****     }
 1367               		.loc 1 669 9 view .LVU413
 1368 013c 8EE1      		ldi r24,lo8(30)
 1369 013e 00C0      		rjmp .L146
 1370               	.L73:
 671:Caterina.c    ****     {
 1371               		.loc 1 671 10 view .LVU414
 671:Caterina.c    ****     {
 1372               		.loc 1 671 13 is_stmt 0 view .LVU415
 1373 0140 C536      		cpi r28,lo8(101)
 1374 0142 01F4      		brne .L74
 1375 0144 F0E0      		ldi r31,0
 1376 0146 E0E0      		ldi r30,0
 1377               	.LBB184:
 676:Caterina.c    ****             boot_spm_busy_wait();
 1378               		.loc 1 676 13 view .LVU416
 1379 0148 83E0      		ldi r24,lo8(3)
 678:Caterina.c    ****             boot_spm_busy_wait();
 1380               		.loc 1 678 13 view .LVU417
 1381 014a 95E0      		ldi r25,lo8(5)
 1382               	.L77:
 676:Caterina.c    ****             boot_spm_busy_wait();
 1383               		.loc 1 676 13 is_stmt 1 view .LVU418
 1384               	/* #APP */
 1385               	 ;  676 "Caterina.c" 1
 1386 014c 8093 5700 		sts 87, r24
 1387 0150 E895      		spm
 1388               		
 1389               	 ;  0 "" 2
 1390               	/* #NOAPP */
 1391               	.L75:
 677:Caterina.c    ****             boot_page_write(CurrFlashAddress);
 1392               		.loc 1 677 13 discriminator 1 view .LVU419
 677:Caterina.c    ****             boot_page_write(CurrFlashAddress);
 1393               		.loc 1 677 13 discriminator 1 view .LVU420
 677:Caterina.c    ****             boot_page_write(CurrFlashAddress);
 1394               		.loc 1 677 13 discriminator 1 view .LVU421
 1395 0152 07B6      		in __tmp_reg__,0x37
 1396 0154 00FC      		sbrc __tmp_reg__,0
 1397 0156 00C0      		rjmp .L75
 678:Caterina.c    ****             boot_spm_busy_wait();
 1398               		.loc 1 678 13 view .LVU422
 1399               	/* #APP */
 1400               	 ;  678 "Caterina.c" 1
 1401 0158 9093 5700 		sts 87, r25
 1402 015c E895      		spm
 1403               		
 1404               	 ;  0 "" 2
 1405               	/* #NOAPP */
 1406               	.L76:
 679:Caterina.c    ****         }
 1407               		.loc 1 679 13 discriminator 1 view .LVU423
 679:Caterina.c    ****         }
 1408               		.loc 1 679 13 discriminator 1 view .LVU424
 679:Caterina.c    ****         }
 1409               		.loc 1 679 13 discriminator 1 view .LVU425
 1410 015e 07B6      		in __tmp_reg__,0x37
 1411 0160 00FC      		sbrc __tmp_reg__,0
 1412 0162 00C0      		rjmp .L76
 674:Caterina.c    ****         {
 1413               		.loc 1 674 81 discriminator 2 view .LVU426
 674:Caterina.c    ****         {
 1414               		.loc 1 674 45 discriminator 2 view .LVU427
 1415 0164 E058      		subi r30,-128
 1416 0166 FF4F      		sbci r31,-1
 674:Caterina.c    ****         {
 1417               		.loc 1 674 9 is_stmt 0 discriminator 2 view .LVU428
 1418 0168 E115      		cp r30,__zero_reg__
 1419 016a 20E7      		ldi r18,112
 1420 016c F207      		cpc r31,r18
 1421 016e 01F4      		brne .L77
 1422 0170 00C0      		rjmp .L145
 1423               	.L74:
 1424               	.LBE184:
 695:Caterina.c    ****     {
 1425               		.loc 1 695 10 is_stmt 1 view .LVU429
 1426               	.LBB185:
 697:Caterina.c    ****     }
 1427               		.loc 1 697 31 is_stmt 0 view .LVU430
 1428 0172 89E0      		ldi r24,lo8(9)
 1429 0174 E1E0      		ldi r30,lo8(1)
 1430 0176 F0E0      		ldi r31,0
 1431               	.LBE185:
 695:Caterina.c    ****     {
 1432               		.loc 1 695 13 view .LVU431
 1433 0178 C237      		cpi r28,lo8(114)
 1434 017a 01F0      		breq .L148
 699:Caterina.c    ****     {
 1435               		.loc 1 699 10 is_stmt 1 view .LVU432
 1436               	.LBB186:
 701:Caterina.c    ****     }
 1437               		.loc 1 701 31 is_stmt 0 view .LVU433
 1438 017c 89E0      		ldi r24,lo8(9)
 1439 017e F0E0      		ldi r31,0
 1440 0180 E0E0      		ldi r30,0
 1441               	.LBE186:
 699:Caterina.c    ****     {
 1442               		.loc 1 699 13 view .LVU434
 1443 0182 C634      		cpi r28,lo8(70)
 1444 0184 01F0      		breq .L148
 703:Caterina.c    ****     {
 1445               		.loc 1 703 10 is_stmt 1 view .LVU435
 1446               	.LBB187:
 705:Caterina.c    ****     }
 1447               		.loc 1 705 31 is_stmt 0 view .LVU436
 1448 0186 89E0      		ldi r24,lo8(9)
 1449 0188 E3E0      		ldi r30,lo8(3)
 1450 018a F0E0      		ldi r31,0
 1451               	.LBE187:
 703:Caterina.c    ****     {
 1452               		.loc 1 703 13 view .LVU437
 1453 018c CE34      		cpi r28,lo8(78)
 1454 018e 01F0      		breq .L148
 707:Caterina.c    ****     {
 1455               		.loc 1 707 10 is_stmt 1 view .LVU438
 707:Caterina.c    ****     {
 1456               		.loc 1 707 13 is_stmt 0 view .LVU439
 1457 0190 C135      		cpi r28,lo8(81)
 1458 0192 01F4      		brne .L81
 709:Caterina.c    ****     }
 1459               		.loc 1 709 9 is_stmt 1 view .LVU440
 1460               	.LBB188:
 709:Caterina.c    ****     }
 1461               		.loc 1 709 31 view .LVU441
 709:Caterina.c    ****     }
 1462               		.loc 1 709 31 view .LVU442
 1463 0194 89E0      		ldi r24,lo8(9)
 1464 0196 E2E0      		ldi r30,lo8(2)
 1465 0198 F0E0      		ldi r31,0
 1466               	.L148:
 1467               	/* #APP */
 1468               	 ;  709 "Caterina.c" 1
 1469 019a 8093 5700 		sts 87, r24
 1470 019e 8491      		lpm r24, Z
 1471               		
 1472               	 ;  0 "" 2
 1473               	.LVL64:
 709:Caterina.c    ****     }
 1474               		.loc 1 709 31 view .LVU443
 1475               	/* #NOAPP */
 1476 01a0 00C0      		rjmp .L146
 1477               	.LVL65:
 1478               	.L81:
 709:Caterina.c    ****     }
 1479               		.loc 1 709 31 is_stmt 0 view .LVU444
 1480               	.LBE188:
 712:Caterina.c    ****     {
 1481               		.loc 1 712 10 is_stmt 1 view .LVU445
 712:Caterina.c    ****     {
 1482               		.loc 1 712 13 is_stmt 0 view .LVU446
 1483 01a2 C236      		cpi r28,lo8(98)
 1484 01a4 01F4      		brne .L82
 714:Caterina.c    **** 
 1485               		.loc 1 714 9 is_stmt 1 view .LVU447
 1486 01a6 89E5      		ldi r24,lo8(89)
 1487 01a8 0E94 0000 		call WriteNextResponseByte
 1488               	.LVL66:
 717:Caterina.c    ****         WriteNextResponseByte(SPM_PAGESIZE & 0xFF);
 1489               		.loc 1 717 9 view .LVU448
 1490 01ac 80E0      		ldi r24,0
 1491 01ae 0E94 0000 		call WriteNextResponseByte
 1492               	.LVL67:
 718:Caterina.c    ****     }
 1493               		.loc 1 718 9 view .LVU449
 1494 01b2 80E8      		ldi r24,lo8(-128)
 1495 01b4 00C0      		rjmp .L146
 1496               	.L82:
 720:Caterina.c    ****     {
 1497               		.loc 1 720 10 view .LVU450
 720:Caterina.c    ****     {
 1498               		.loc 1 720 13 is_stmt 0 view .LVU451
 1499 01b6 C234      		cpi r28,lo8(66)
 1500 01b8 01F0      		breq .L83
 720:Caterina.c    ****     {
 1501               		.loc 1 720 31 discriminator 1 view .LVU452
 1502 01ba C736      		cpi r28,lo8(103)
 1503 01bc 01F0      		breq .+2
 1504 01be 00C0      		rjmp .L84
 1505               	.L83:
 723:Caterina.c    ****         // Delegate the block write/read to a separate function for clarity
 1506               		.loc 1 723 9 is_stmt 1 view .LVU453
 723:Caterina.c    ****         // Delegate the block write/read to a separate function for clarity
 1507               		.loc 1 723 17 is_stmt 0 view .LVU454
 1508 01c0 1092 0000 		sts Timeout+1,__zero_reg__
 1509 01c4 1092 0000 		sts Timeout,__zero_reg__
 725:Caterina.c    ****     }
 1510               		.loc 1 725 9 is_stmt 1 view .LVU455
 1511               	.LVL68:
 1512               	.LBB189:
 1513               	.LBI189:
 398:Caterina.c    **** {
 1514               		.loc 1 398 13 view .LVU456
 1515               	.LBB190:
 400:Caterina.c    ****     char     MemoryType;
 1516               		.loc 1 400 5 view .LVU457
 401:Caterina.c    **** 
 1517               		.loc 1 401 5 view .LVU458
 403:Caterina.c    ****     uint8_t  LowByte  = 0;
 1518               		.loc 1 403 5 view .LVU459
 404:Caterina.c    **** 
 1519               		.loc 1 404 5 view .LVU460
 406:Caterina.c    ****     BlockSize |=  FetchNextCommandByte();
 1520               		.loc 1 406 5 view .LVU461
 406:Caterina.c    ****     BlockSize |=  FetchNextCommandByte();
 1521               		.loc 1 406 19 is_stmt 0 view .LVU462
 1522 01c8 0E94 0000 		call FetchNextCommandByte
 1523               	.LVL69:
 1524 01cc 182F      		mov r17,r24
 1525               	.LVL70:
 407:Caterina.c    **** 
 1526               		.loc 1 407 5 is_stmt 1 view .LVU463
 407:Caterina.c    **** 
 1527               		.loc 1 407 19 is_stmt 0 view .LVU464
 1528 01ce 0E94 0000 		call FetchNextCommandByte
 1529               	.LVL71:
 1530 01d2 082F      		mov r16,r24
 1531               	.LVL72:
 409:Caterina.c    **** 
 1532               		.loc 1 409 5 is_stmt 1 view .LVU465
 409:Caterina.c    **** 
 1533               		.loc 1 409 19 is_stmt 0 view .LVU466
 1534 01d4 0E94 0000 		call FetchNextCommandByte
 1535               	.LVL73:
 1536 01d8 D82F      		mov r29,r24
 1537               	.LVL74:
 411:Caterina.c    ****     {
 1538               		.loc 1 411 5 is_stmt 1 view .LVU467
 411:Caterina.c    ****     {
 1539               		.loc 1 411 29 is_stmt 0 view .LVU468
 1540 01da 8BEB      		ldi r24,lo8(-69)
 1541               	.LVL75:
 411:Caterina.c    ****     {
 1542               		.loc 1 411 29 view .LVU469
 1543 01dc 8D0F      		add r24,r29
 411:Caterina.c    ****     {
 1544               		.loc 1 411 8 view .LVU470
 1545 01de 8230      		cpi r24,lo8(2)
 1546 01e0 00F0      		brlo .L85
 1547               	.LVL76:
 1548               	.L109:
 414:Caterina.c    **** 
 1549               		.loc 1 414 9 is_stmt 1 view .LVU471
 1550 01e2 8FE3      		ldi r24,lo8(63)
 1551 01e4 00C0      		rjmp .L146
 1552               	.LVL77:
 1553               	.L85:
 421:Caterina.c    **** 
 1554               		.loc 1 421 5 view .LVU472
 421:Caterina.c    **** 
 1555               		.loc 1 421 12 is_stmt 0 view .LVU473
 1556 01e6 1092 6F00 		sts 111,__zero_reg__
 424:Caterina.c    ****     {
 1557               		.loc 1 424 5 is_stmt 1 view .LVU474
 424:Caterina.c    ****     {
 1558               		.loc 1 424 8 is_stmt 0 view .LVU475
 1559 01ea C736      		cpi r28,lo8(103)
 1560 01ec 01F0      		breq .+2
 1561 01ee 00C0      		rjmp .L86
 427:Caterina.c    **** 
 1562               		.loc 1 427 9 is_stmt 1 view .LVU476
 1563 01f0 81E1      		ldi r24,lo8(17)
 1564               	/* #APP */
 1565               	 ;  427 "Caterina.c" 1
 1566 01f2 8093 5700 		sts 87, r24
 1567 01f6 E895      		spm
 1568               		
 1569               	 ;  0 "" 2
 429:Caterina.c    ****         {
 1570               		.loc 1 429 9 view .LVU477
 403:Caterina.c    ****     uint8_t  LowByte  = 0;
 1571               		.loc 1 403 14 is_stmt 0 view .LVU478
 1572               	/* #NOAPP */
 1573 01f8 C0E0      		ldi r28,0
 1574               	.LVL78:
 444:Caterina.c    ****             }
 1575               		.loc 1 444 17 view .LVU479
 1576 01fa BB24      		clr r11
 1577 01fc B394      		inc r11
 1578               	.LVL79:
 1579               	.L87:
 429:Caterina.c    ****         {
 1580               		.loc 1 429 15 is_stmt 1 view .LVU480
 429:Caterina.c    ****         {
 1581               		.loc 1 429 25 is_stmt 0 view .LVU481
 1582               	.LVL80:
 1583 01fe 0150      		subi r16,1
 1584 0200 1109      		sbc r17,__zero_reg__
 1585 0202 00F4      		brcc .L91
 1586               	.L92:
 511:Caterina.c    **** }
 1587               		.loc 1 511 5 is_stmt 1 view .LVU482
 511:Caterina.c    **** }
 1588               		.loc 1 511 12 is_stmt 0 view .LVU483
 1589 0204 82E0      		ldi r24,lo8(2)
 1590 0206 8093 6F00 		sts 111,r24
 1591 020a 00C0      		rjmp .L62
 1592               	.LVL81:
 1593               	.L91:
 431:Caterina.c    ****             {
 1594               		.loc 1 431 13 is_stmt 1 view .LVU484
 1595 020c C090 0000 		lds r12,CurrAddress
 1596 0210 D090 0000 		lds r13,CurrAddress+1
 1597 0214 E090 0000 		lds r14,CurrAddress+2
 1598 0218 F090 0000 		lds r15,CurrAddress+3
 431:Caterina.c    ****             {
 1599               		.loc 1 431 16 is_stmt 0 view .LVU485
 1600 021c D634      		cpi r29,lo8(70)
 1601 021e 01F4      		brne .L88
 437:Caterina.c    ****                 #endif
 1602               		.loc 1 437 17 is_stmt 1 view .LVU486
 1603               	.LBB191:
 437:Caterina.c    ****                 #endif
 1604               		.loc 1 437 39 view .LVU487
 1605               	.LVL82:
 437:Caterina.c    ****                 #endif
 1606               		.loc 1 437 39 view .LVU488
 437:Caterina.c    ****                 #endif
 1607               		.loc 1 437 39 view .LVU489
 1608 0220 EC2F      		mov r30,r28
 1609 0222 F0E0      		ldi r31,0
 1610 0224 EC29      		or r30,r12
 1611 0226 FD29      		or r31,r13
 1612               	/* #APP */
 1613               	 ;  437 "Caterina.c" 1
 1614 0228 8491      		lpm r24, Z
 1615               		
 1616               	 ;  0 "" 2
 1617               	.LVL83:
 437:Caterina.c    ****                 #endif
 1618               		.loc 1 437 39 view .LVU490
 1619               	/* #NOAPP */
 1620               	.LBE191:
 437:Caterina.c    ****                 #endif
 1621               		.loc 1 437 17 is_stmt 0 view .LVU491
 1622 022a 0E94 0000 		call WriteNextResponseByte
 1623               	.LVL84:
 441:Caterina.c    ****                   CurrAddress += 2;
 1624               		.loc 1 441 17 is_stmt 1 view .LVU492
 441:Caterina.c    ****                   CurrAddress += 2;
 1625               		.loc 1 441 20 is_stmt 0 view .LVU493
 1626 022e CC23      		tst r28
 1627 0230 01F0      		breq .L89
 442:Caterina.c    **** 
 1628               		.loc 1 442 19 is_stmt 1 view .LVU494
 442:Caterina.c    **** 
 1629               		.loc 1 442 31 is_stmt 0 view .LVU495
 1630 0232 82E0      		ldi r24,2
 1631 0234 C80E      		add r12,r24
 1632 0236 D11C      		adc r13,__zero_reg__
 1633 0238 E11C      		adc r14,__zero_reg__
 1634 023a F11C      		adc r15,__zero_reg__
 1635               	.LVL85:
 442:Caterina.c    **** 
 1636               		.loc 1 442 31 view .LVU496
 1637 023c C092 0000 		sts CurrAddress,r12
 1638 0240 D092 0000 		sts CurrAddress+1,r13
 1639 0244 E092 0000 		sts CurrAddress+2,r14
 1640 0248 F092 0000 		sts CurrAddress+3,r15
 1641               	.LVL86:
 1642               	.L89:
 444:Caterina.c    ****             }
 1643               		.loc 1 444 17 is_stmt 1 view .LVU497
 1644 024c CB25      		eor r28,r11
 1645               	.LVL87:
 444:Caterina.c    ****             }
 1646               		.loc 1 444 17 is_stmt 0 view .LVU498
 1647 024e 00C0      		rjmp .L87
 1648               	.L88:
 449:Caterina.c    **** 
 1649               		.loc 1 449 17 is_stmt 1 view .LVU499
 449:Caterina.c    **** 
 1650               		.loc 1 449 89 is_stmt 0 view .LVU500
 1651 0250 D701      		movw r26,r14
 1652 0252 C601      		movw r24,r12
 1653 0254 B695      		lsr r27
 1654 0256 A795      		ror r26
 1655 0258 9795      		ror r25
 1656 025a 8795      		ror r24
 449:Caterina.c    **** 
 1657               		.loc 1 449 17 view .LVU501
 1658 025c 0E94 0000 		call eeprom_read_byte
 1659               	.LVL88:
 1660 0260 0E94 0000 		call WriteNextResponseByte
 1661               	.LVL89:
 452:Caterina.c    ****             }
 1662               		.loc 1 452 17 is_stmt 1 view .LVU502
 452:Caterina.c    ****             }
 1663               		.loc 1 452 29 is_stmt 0 view .LVU503
 1664 0264 E2E0      		ldi r30,2
 1665 0266 CE0E      		add r12,r30
 1666 0268 D11C      		adc r13,__zero_reg__
 1667 026a E11C      		adc r14,__zero_reg__
 1668 026c F11C      		adc r15,__zero_reg__
 1669 026e C092 0000 		sts CurrAddress,r12
 1670 0272 D092 0000 		sts CurrAddress+1,r13
 1671 0276 E092 0000 		sts CurrAddress+2,r14
 1672 027a F092 0000 		sts CurrAddress+3,r15
 1673 027e 00C0      		rjmp .L87
 1674               	.LVL90:
 1675               	.L86:
 1676               	.LBB192:
 458:Caterina.c    **** 
 1677               		.loc 1 458 9 is_stmt 1 view .LVU504
 458:Caterina.c    **** 
 1678               		.loc 1 458 18 is_stmt 0 view .LVU505
 1679 0280 4090 0000 		lds r4,CurrAddress
 1680 0284 5090 0000 		lds r5,CurrAddress+1
 1681 0288 6090 0000 		lds r6,CurrAddress+2
 1682 028c 7090 0000 		lds r7,CurrAddress+3
 460:Caterina.c    ****         {
 1683               		.loc 1 460 9 is_stmt 1 view .LVU506
 460:Caterina.c    ****         {
 1684               		.loc 1 460 12 is_stmt 0 view .LVU507
 1685 0290 D634      		cpi r29,lo8(70)
 1686 0292 01F4      		brne .L117
 462:Caterina.c    ****             boot_spm_busy_wait();
 1687               		.loc 1 462 13 is_stmt 1 view .LVU508
 1688 0294 83E0      		ldi r24,lo8(3)
 1689 0296 F201      		movw r30,r4
 1690               	/* #APP */
 1691               	 ;  462 "Caterina.c" 1
 1692 0298 8093 5700 		sts 87, r24
 1693 029c E895      		spm
 1694               		
 1695               	 ;  0 "" 2
 1696               	/* #NOAPP */
 1697               	.L94:
 463:Caterina.c    ****         }
 1698               		.loc 1 463 13 view .LVU509
 463:Caterina.c    ****         }
 1699               		.loc 1 463 13 view .LVU510
 463:Caterina.c    ****         }
 1700               		.loc 1 463 13 view .LVU511
 1701 029e 07B6      		in __tmp_reg__,0x37
 1702 02a0 00FC      		sbrc __tmp_reg__,0
 1703 02a2 00C0      		rjmp .L94
 1704               	.L117:
 1705 02a4 C0E0      		ldi r28,0
 1706               	.LVL91:
 463:Caterina.c    ****         }
 1707               		.loc 1 463 13 is_stmt 0 view .LVU512
 1708 02a6 F12C      		mov r15,__zero_reg__
 484:Caterina.c    ****             }
 1709               		.loc 1 484 17 view .LVU513
 1710 02a8 EE24      		clr r14
 1711 02aa E394      		inc r14
 1712 02ac 00C0      		rjmp .L144
 1713               	.LVL92:
 1714               	.L99:
 468:Caterina.c    ****             {
 1715               		.loc 1 468 13 is_stmt 1 view .LVU514
 468:Caterina.c    ****             {
 1716               		.loc 1 468 16 is_stmt 0 view .LVU515
 1717 02ae D634      		cpi r29,lo8(70)
 1718 02b0 01F0      		breq .+2
 1719 02b2 00C0      		rjmp .L95
 471:Caterina.c    ****                 {
 1720               		.loc 1 471 17 is_stmt 1 view .LVU516
 471:Caterina.c    ****                 {
 1721               		.loc 1 471 20 is_stmt 0 view .LVU517
 1722 02b4 FF20      		tst r15
 1723 02b6 01F0      		breq .L96
 474:Caterina.c    **** 
 1724               		.loc 1 474 21 is_stmt 1 view .LVU518
 1725 02b8 8090 0000 		lds r8,CurrAddress
 1726 02bc 9090 0000 		lds r9,CurrAddress+1
 1727 02c0 A090 0000 		lds r10,CurrAddress+2
 1728 02c4 B090 0000 		lds r11,CurrAddress+3
 1729 02c8 0E94 0000 		call FetchNextCommandByte
 1730               	.LVL93:
 1731 02cc 982F      		mov r25,r24
 1732 02ce 8C2F      		mov r24,r28
 1733 02d0 F401      		movw r30,r8
 1734               	/* #APP */
 1735               	 ;  474 "Caterina.c" 1
 1736 02d2 0C01      		movw  r0, r24
 1737 02d4 E092 5700 		sts 87, r14
 1738 02d8 E895      		spm
 1739 02da 1124      		clr  r1
 1740               		
 1741               	 ;  0 "" 2
 477:Caterina.c    ****                 }
 1742               		.loc 1 477 21 view .LVU519
 477:Caterina.c    ****                 }
 1743               		.loc 1 477 33 is_stmt 0 view .LVU520
 1744               	/* #NOAPP */
 1745 02dc F2E0      		ldi r31,2
 1746 02de 8F0E      		add r8,r31
 1747 02e0 911C      		adc r9,__zero_reg__
 1748 02e2 A11C      		adc r10,__zero_reg__
 1749 02e4 B11C      		adc r11,__zero_reg__
 1750 02e6 8092 0000 		sts CurrAddress,r8
 1751 02ea 9092 0000 		sts CurrAddress+1,r9
 1752 02ee A092 0000 		sts CurrAddress+2,r10
 1753 02f2 B092 0000 		sts CurrAddress+3,r11
 1754               	.LVL94:
 1755               	.L97:
 484:Caterina.c    ****             }
 1756               		.loc 1 484 17 is_stmt 1 view .LVU521
 1757 02f6 FE24      		eor r15,r14
 1758               	.LVL95:
 1759               	.L144:
 466:Caterina.c    ****         {
 1760               		.loc 1 466 15 view .LVU522
 466:Caterina.c    ****         {
 1761               		.loc 1 466 25 is_stmt 0 view .LVU523
 1762               	.LVL96:
 1763 02f8 0150      		subi r16,1
 1764 02fa 1109      		sbc r17,__zero_reg__
 1765 02fc 00F4      		brcc .L99
 497:Caterina.c    ****         {
 1766               		.loc 1 497 9 is_stmt 1 view .LVU524
 497:Caterina.c    ****         {
 1767               		.loc 1 497 12 is_stmt 0 view .LVU525
 1768 02fe D634      		cpi r29,lo8(70)
 1769 0300 01F4      		brne .L100
 500:Caterina.c    **** 
 1770               		.loc 1 500 13 is_stmt 1 view .LVU526
 1771 0302 85E0      		ldi r24,lo8(5)
 1772 0304 F201      		movw r30,r4
 1773               	/* #APP */
 1774               	 ;  500 "Caterina.c" 1
 1775 0306 8093 5700 		sts 87, r24
 1776 030a E895      		spm
 1777               		
 1778               	 ;  0 "" 2
 1779               	/* #NOAPP */
 1780               	.L101:
 503:Caterina.c    ****         }
 1781               		.loc 1 503 13 view .LVU527
 503:Caterina.c    ****         }
 1782               		.loc 1 503 13 view .LVU528
 503:Caterina.c    ****         }
 1783               		.loc 1 503 13 view .LVU529
 1784 030c 07B6      		in __tmp_reg__,0x37
 1785 030e 00FC      		sbrc __tmp_reg__,0
 1786 0310 00C0      		rjmp .L101
 1787               	.L100:
 507:Caterina.c    ****     }
 1788               		.loc 1 507 9 view .LVU530
 1789 0312 8DE0      		ldi r24,lo8(13)
 1790 0314 0E94 0000 		call WriteNextResponseByte
 1791               	.LVL97:
 1792 0318 00C0      		rjmp .L92
 1793               	.L96:
 481:Caterina.c    ****                 }
 1794               		.loc 1 481 21 view .LVU531
 481:Caterina.c    ****                 }
 1795               		.loc 1 481 31 is_stmt 0 view .LVU532
 1796 031a 0E94 0000 		call FetchNextCommandByte
 1797               	.LVL98:
 1798 031e C82F      		mov r28,r24
 1799               	.LVL99:
 481:Caterina.c    ****                 }
 1800               		.loc 1 481 31 view .LVU533
 1801 0320 00C0      		rjmp .L97
 1802               	.LVL100:
 1803               	.L95:
 489:Caterina.c    **** 
 1804               		.loc 1 489 17 is_stmt 1 view .LVU534
 1805 0322 0E94 0000 		call FetchNextCommandByte
 1806               	.LVL101:
 1807 0326 682F      		mov r22,r24
 489:Caterina.c    **** 
 1808               		.loc 1 489 69 is_stmt 0 view .LVU535
 1809 0328 8091 0000 		lds r24,CurrAddress
 1810 032c 9091 0000 		lds r25,CurrAddress+1
 1811 0330 A091 0000 		lds r26,CurrAddress+2
 1812 0334 B091 0000 		lds r27,CurrAddress+3
 1813 0338 B695      		lsr r27
 1814 033a A795      		ror r26
 1815 033c 9795      		ror r25
 1816 033e 8795      		ror r24
 489:Caterina.c    **** 
 1817               		.loc 1 489 17 view .LVU536
 1818 0340 0E94 0000 		call eeprom_write_byte
 1819               	.LVL102:
 492:Caterina.c    ****             }
 1820               		.loc 1 492 17 is_stmt 1 view .LVU537
 492:Caterina.c    ****             }
 1821               		.loc 1 492 29 is_stmt 0 view .LVU538
 1822 0344 8091 0000 		lds r24,CurrAddress
 1823 0348 9091 0000 		lds r25,CurrAddress+1
 1824 034c A091 0000 		lds r26,CurrAddress+2
 1825 0350 B091 0000 		lds r27,CurrAddress+3
 1826 0354 0296      		adiw r24,2
 1827 0356 A11D      		adc r26,__zero_reg__
 1828 0358 B11D      		adc r27,__zero_reg__
 1829 035a 8093 0000 		sts CurrAddress,r24
 1830 035e 9093 0000 		sts CurrAddress+1,r25
 1831 0362 A093 0000 		sts CurrAddress+2,r26
 1832 0366 B093 0000 		sts CurrAddress+3,r27
 1833 036a 00C0      		rjmp .L144
 1834               	.LVL103:
 1835               	.L84:
 492:Caterina.c    ****             }
 1836               		.loc 1 492 29 view .LVU539
 1837               	.LBE192:
 1838               	.LBE190:
 1839               	.LBE189:
 729:Caterina.c    ****     {
 1840               		.loc 1 729 10 is_stmt 1 view .LVU540
 729:Caterina.c    ****     {
 1841               		.loc 1 729 13 is_stmt 0 view .LVU541
 1842 036c C334      		cpi r28,lo8(67)
 1843 036e 01F4      		brne .L102
 732:Caterina.c    **** 
 1844               		.loc 1 732 9 is_stmt 1 view .LVU542
 1845 0370 C091 0000 		lds r28,CurrAddress
 1846 0374 D091 0000 		lds r29,CurrAddress+1
 1847               	.LVL104:
 732:Caterina.c    **** 
 1848               		.loc 1 732 9 is_stmt 0 view .LVU543
 1849 0378 0E94 0000 		call FetchNextCommandByte
 1850               	.LVL105:
 1851 037c 90E0      		ldi r25,0
 1852 037e 21E0      		ldi r18,lo8(1)
 1853 0380 FE01      		movw r30,r28
 1854               	/* #APP */
 1855               	 ;  732 "Caterina.c" 1
 1856 0382 0C01      		movw  r0, r24
 1857 0384 2093 5700 		sts 87, r18
 1858 0388 E895      		spm
 1859 038a 1124      		clr  r1
 1860               		
 1861               	 ;  0 "" 2
 735:Caterina.c    ****     }
 1862               		.loc 1 735 9 is_stmt 1 view .LVU544
 1863               	/* #NOAPP */
 1864 038c 00C0      		rjmp .L145
 1865               	.LVL106:
 1866               	.L102:
 737:Caterina.c    ****     {
 1867               		.loc 1 737 10 view .LVU545
 737:Caterina.c    ****     {
 1868               		.loc 1 737 13 is_stmt 0 view .LVU546
 1869 038e C336      		cpi r28,lo8(99)
 1870 0390 01F4      		brne .L103
 740:Caterina.c    **** 
 1871               		.loc 1 740 9 is_stmt 1 view .LVU547
 1872 0392 C090 0000 		lds r12,CurrAddress
 1873 0396 D090 0000 		lds r13,CurrAddress+1
 1874 039a E090 0000 		lds r14,CurrAddress+2
 1875 039e F090 0000 		lds r15,CurrAddress+3
 1876 03a2 0E94 0000 		call FetchNextCommandByte
 1877               	.LVL107:
 1878 03a6 F601      		movw r30,r12
 1879 03a8 E160      		ori r30,1
 1880 03aa 90E0      		ldi r25,0
 1881 03ac 21E0      		ldi r18,lo8(1)
 1882               	/* #APP */
 1883               	 ;  740 "Caterina.c" 1
 1884 03ae 0C01      		movw  r0, r24
 1885 03b0 2093 5700 		sts 87, r18
 1886 03b4 E895      		spm
 1887 03b6 1124      		clr  r1
 1888               		
 1889               	 ;  0 "" 2
 743:Caterina.c    **** 
 1890               		.loc 1 743 9 view .LVU548
 743:Caterina.c    **** 
 1891               		.loc 1 743 21 is_stmt 0 view .LVU549
 1892               	/* #NOAPP */
 1893 03b8 F2E0      		ldi r31,2
 1894 03ba CF0E      		add r12,r31
 1895 03bc D11C      		adc r13,__zero_reg__
 1896 03be E11C      		adc r14,__zero_reg__
 1897 03c0 F11C      		adc r15,__zero_reg__
 1898 03c2 C092 0000 		sts CurrAddress,r12
 1899 03c6 D092 0000 		sts CurrAddress+1,r13
 1900 03ca E092 0000 		sts CurrAddress+2,r14
 1901 03ce F092 0000 		sts CurrAddress+3,r15
 746:Caterina.c    ****     }
 1902               		.loc 1 746 9 is_stmt 1 view .LVU550
 1903 03d2 00C0      		rjmp .L145
 1904               	.L103:
 748:Caterina.c    ****     {
 1905               		.loc 1 748 10 view .LVU551
 748:Caterina.c    ****     {
 1906               		.loc 1 748 13 is_stmt 0 view .LVU552
 1907 03d4 CD36      		cpi r28,lo8(109)
 1908 03d6 01F4      		brne .L104
 751:Caterina.c    **** 
 1909               		.loc 1 751 9 is_stmt 1 view .LVU553
 1910 03d8 E091 0000 		lds r30,CurrAddress
 1911 03dc F091 0000 		lds r31,CurrAddress+1
 1912 03e0 85E0      		ldi r24,lo8(5)
 1913               	/* #APP */
 1914               	 ;  751 "Caterina.c" 1
 1915 03e2 8093 5700 		sts 87, r24
 1916 03e6 E895      		spm
 1917               		
 1918               	 ;  0 "" 2
 1919               	/* #NOAPP */
 1920               	.L105:
 754:Caterina.c    **** 
 1921               		.loc 1 754 9 discriminator 1 view .LVU554
 754:Caterina.c    **** 
 1922               		.loc 1 754 9 discriminator 1 view .LVU555
 754:Caterina.c    **** 
 1923               		.loc 1 754 9 discriminator 1 view .LVU556
 1924 03e8 07B6      		in __tmp_reg__,0x37
 1925 03ea 00FC      		sbrc __tmp_reg__,0
 1926 03ec 00C0      		rjmp .L105
 1927 03ee 00C0      		rjmp .L145
 1928               	.L104:
 759:Caterina.c    ****     {
 1929               		.loc 1 759 10 view .LVU557
 759:Caterina.c    ****     {
 1930               		.loc 1 759 13 is_stmt 0 view .LVU558
 1931 03f0 C235      		cpi r28,lo8(82)
 1932 03f2 01F4      		brne .L106
 1933               	.LBB193:
 764:Caterina.c    ****         #endif
 1934               		.loc 1 764 9 is_stmt 1 view .LVU559
 1935               	.LBB194:
 764:Caterina.c    ****         #endif
 1936               		.loc 1 764 32 view .LVU560
 1937 03f4 E091 0000 		lds r30,CurrAddress
 1938 03f8 F091 0000 		lds r31,CurrAddress+1
 1939               	.LVL108:
 764:Caterina.c    ****         #endif
 1940               		.loc 1 764 32 view .LVU561
 764:Caterina.c    ****         #endif
 1941               		.loc 1 764 32 view .LVU562
 1942               	/* #APP */
 1943               	 ;  764 "Caterina.c" 1
 1944 03fc C591      		lpm r28, Z+
 1945 03fe D491      		lpm r29, Z
 1946               		
 1947               	 ;  0 "" 2
 1948               	.LVL109:
 764:Caterina.c    ****         #endif
 1949               		.loc 1 764 32 view .LVU563
 764:Caterina.c    ****         #endif
 1950               		.loc 1 764 32 is_stmt 0 view .LVU564
 1951               	/* #NOAPP */
 1952               	.LBE194:
 767:Caterina.c    ****         WriteNextResponseByte(ProgramWord & 0xFF);
 1953               		.loc 1 767 9 is_stmt 1 view .LVU565
 1954 0400 8D2F      		mov r24,r29
 1955 0402 0E94 0000 		call WriteNextResponseByte
 1956               	.LVL110:
 768:Caterina.c    ****     }
 1957               		.loc 1 768 9 view .LVU566
 1958 0406 8C2F      		mov r24,r28
 1959 0408 00C0      		rjmp .L146
 1960               	.LVL111:
 1961               	.L106:
 768:Caterina.c    ****     }
 1962               		.loc 1 768 9 is_stmt 0 view .LVU567
 1963               	.LBE193:
 772:Caterina.c    ****     {
 1964               		.loc 1 772 10 is_stmt 1 view .LVU568
 772:Caterina.c    ****     {
 1965               		.loc 1 772 13 is_stmt 0 view .LVU569
 1966 040a C434      		cpi r28,lo8(68)
 1967 040c 01F4      		brne .L107
 775:Caterina.c    **** 
 1968               		.loc 1 775 9 is_stmt 1 view .LVU570
 1969 040e 0E94 0000 		call FetchNextCommandByte
 1970               	.LVL112:
 1971 0412 682F      		mov r22,r24
 775:Caterina.c    **** 
 1972               		.loc 1 775 61 is_stmt 0 view .LVU571
 1973 0414 8091 0000 		lds r24,CurrAddress
 1974 0418 9091 0000 		lds r25,CurrAddress+1
 1975 041c A091 0000 		lds r26,CurrAddress+2
 1976 0420 B091 0000 		lds r27,CurrAddress+3
 1977 0424 B695      		lsr r27
 1978 0426 A795      		ror r26
 1979 0428 9795      		ror r25
 1980 042a 8795      		ror r24
 775:Caterina.c    **** 
 1981               		.loc 1 775 9 view .LVU572
 1982 042c 0E94 0000 		call eeprom_write_byte
 1983               	.LVL113:
 778:Caterina.c    **** 
 1984               		.loc 1 778 9 is_stmt 1 view .LVU573
 778:Caterina.c    **** 
 1985               		.loc 1 778 21 is_stmt 0 view .LVU574
 1986 0430 8091 0000 		lds r24,CurrAddress
 1987 0434 9091 0000 		lds r25,CurrAddress+1
 1988 0438 A091 0000 		lds r26,CurrAddress+2
 1989 043c B091 0000 		lds r27,CurrAddress+3
 1990 0440 0296      		adiw r24,2
 1991 0442 A11D      		adc r26,__zero_reg__
 1992 0444 B11D      		adc r27,__zero_reg__
 1993 0446 00C0      		rjmp .L147
 1994               	.L107:
 783:Caterina.c    ****     {
 1995               		.loc 1 783 10 is_stmt 1 view .LVU575
 783:Caterina.c    ****     {
 1996               		.loc 1 783 13 is_stmt 0 view .LVU576
 1997 0448 C436      		cpi r28,lo8(100)
 1998 044a 01F4      		brne .L108
 786:Caterina.c    **** 
 1999               		.loc 1 786 9 is_stmt 1 view .LVU577
 786:Caterina.c    **** 
 2000               		.loc 1 786 82 is_stmt 0 view .LVU578
 2001 044c C090 0000 		lds r12,CurrAddress
 2002 0450 D090 0000 		lds r13,CurrAddress+1
 2003 0454 E090 0000 		lds r14,CurrAddress+2
 2004 0458 F090 0000 		lds r15,CurrAddress+3
 2005 045c D701      		movw r26,r14
 2006 045e C601      		movw r24,r12
 2007 0460 B695      		lsr r27
 2008 0462 A795      		ror r26
 2009 0464 9795      		ror r25
 2010 0466 8795      		ror r24
 786:Caterina.c    **** 
 2011               		.loc 1 786 9 view .LVU579
 2012 0468 0E94 0000 		call eeprom_read_byte
 2013               	.LVL114:
 2014 046c 0E94 0000 		call WriteNextResponseByte
 2015               	.LVL115:
 789:Caterina.c    ****     }
 2016               		.loc 1 789 9 is_stmt 1 view .LVU580
 789:Caterina.c    ****     }
 2017               		.loc 1 789 21 is_stmt 0 view .LVU581
 2018 0470 22E0      		ldi r18,2
 2019 0472 C20E      		add r12,r18
 2020 0474 D11C      		adc r13,__zero_reg__
 2021 0476 E11C      		adc r14,__zero_reg__
 2022 0478 F11C      		adc r15,__zero_reg__
 2023 047a C092 0000 		sts CurrAddress,r12
 2024 047e D092 0000 		sts CurrAddress+1,r13
 2025 0482 E092 0000 		sts CurrAddress+2,r14
 2026 0486 F092 0000 		sts CurrAddress+3,r15
 2027 048a 00C0      		rjmp .L62
 2028               	.L108:
 792:Caterina.c    ****     {
 2029               		.loc 1 792 10 is_stmt 1 view .LVU582
 792:Caterina.c    ****     {
 2030               		.loc 1 792 13 is_stmt 0 view .LVU583
 2031 048c CB31      		cpi r28,lo8(27)
 2032 048e 01F4      		brne .+2
 2033 0490 00C0      		rjmp .L62
 2034 0492 00C0      		rjmp .L109
 2035               	.LVL116:
 2036               	.L114:
 813:Caterina.c    ****               return;
 2037               		.loc 1 813 13 is_stmt 1 view .LVU584
 813:Caterina.c    ****               return;
 2038               		.loc 1 813 17 is_stmt 0 view .LVU585
 2039 0494 8EB3      		in r24,0x1e
 813:Caterina.c    ****               return;
 2040               		.loc 1 813 16 view .LVU586
 2041 0496 8823      		tst r24
 2042 0498 01F0      		breq .L56
 2043               	.L111:
 811:Caterina.c    ****         {
 2044               		.loc 1 811 15 is_stmt 1 view .LVU587
 2045               	.LBB195:
 2046               	.LBI195:
 465:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 2047               		.loc 2 465 23 view .LVU588
 2048               	.LBB196:
 467:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 2049               		.loc 2 467 5 view .LVU589
 467:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			}
 2050               		.loc 2 467 14 is_stmt 0 view .LVU590
 2051 049a 8091 E800 		lds r24,232
 2052               	.LBE196:
 2053               	.LBE195:
 811:Caterina.c    ****         {
 2054               		.loc 1 811 15 view .LVU591
 2055 049e 80FF      		sbrs r24,0
 2056 04a0 00C0      		rjmp .L114
 817:Caterina.c    ****     }
 2057               		.loc 1 817 9 is_stmt 1 view .LVU592
 2058               	.LBB197:
 2059               	.LBI197:
 513:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 			{
 2060               		.loc 2 513 23 view .LVU593
 2061               	.LBB198:
 516:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 2062               		.loc 2 516 6 view .LVU594
 516:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 				#else
 2063               		.loc 2 516 13 is_stmt 0 view .LVU595
 2064 04a2 8091 E800 		lds r24,232
 2065 04a6 8E77      		andi r24,lo8(126)
 2066 04a8 8093 E800 		sts 232,r24
 520:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/Endpoint_AVR8.h **** 
 2067               		.loc 2 520 4 view .LVU596
 2068 04ac 00C0      		rjmp .L115
 2069               	.L116:
 2070               	.LBE198:
 2071               	.LBE197:
 823:Caterina.c    ****           return;
 2072               		.loc 1 823 9 is_stmt 1 view .LVU597
 823:Caterina.c    ****           return;
 2073               		.loc 1 823 13 is_stmt 0 view .LVU598
 2074 04ae 8EB3      		in r24,0x1e
 823:Caterina.c    ****           return;
 2075               		.loc 1 823 12 view .LVU599
 2076 04b0 8111      		cpse r24,__zero_reg__
 2077 04b2 00C0      		rjmp .L115
 2078               	.LVL117:
 2079               	.L56:
 2080               	/* epilogue start */
 832:Caterina.c    **** }
 2081               		.loc 1 832 1 view .LVU600
 2082 04b4 DF91      		pop r29
 2083 04b6 CF91      		pop r28
 2084 04b8 1F91      		pop r17
 2085 04ba 0F91      		pop r16
 2086 04bc FF90      		pop r15
 2087 04be EF90      		pop r14
 2088 04c0 DF90      		pop r13
 2089 04c2 CF90      		pop r12
 2090 04c4 BF90      		pop r11
 2091 04c6 AF90      		pop r10
 2092 04c8 9F90      		pop r9
 2093 04ca 8F90      		pop r8
 2094 04cc 7F90      		pop r7
 2095 04ce 6F90      		pop r6
 2096 04d0 5F90      		pop r5
 2097 04d2 4F90      		pop r4
 2098 04d4 0895      		ret
 2099               		.cfi_endproc
 2100               	.LFE116:
 2102               		.section	.text.startup.main,"ax",@progbits
 2103               	.global	main
 2105               	main:
 2106               	.LFB108:
 242:Caterina.c    ****     /* Clear all reset flags - some may be used by sketch */
 2107               		.loc 1 242 1 is_stmt 1 view -0
 2108               		.cfi_startproc
 2109               	/* prologue: function */
 2110               	/* frame size = 0 */
 2111               	/* stack size = 0 */
 2112               	.L__stack_usage = 0
 244:Caterina.c    ****     /* Watchdog may be configured with a 15 ms period so must disable it before going any further *
 2113               		.loc 1 244 5 view .LVU602
 244:Caterina.c    ****     /* Watchdog may be configured with a 15 ms period so must disable it before going any further *
 2114               		.loc 1 244 11 is_stmt 0 view .LVU603
 2115 0000 14BE      		out 0x34,__zero_reg__
 246:Caterina.c    **** 
 2116               		.loc 1 246 5 is_stmt 1 view .LVU604
 2117               	.LBB199:
 2118               	.LBI199:
 2119               		.file 4 "/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h"
   1:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    All rights reserved.
   4:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
   5:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
   8:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
  11:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****      distribution.
  15:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
  16:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
  20:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
  32:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** /* $Id: wdt.h 2503 2016-02-07 22:59:47Z joerg_wunsch $ */
  33:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
  34:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** /*
  35:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****  */
  37:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
  38:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
  41:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
  44:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** /** \file */
  45:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
  48:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     the manipulation.
  56:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
  57:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
  61:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     the following:
  68:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
  69:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     \code
  70:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
  73:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
  75:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     {
  80:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****       wdt_disable();
  83:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     }
  84:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     \endcode
  85:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
  86:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** */
  91:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
  92:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** /**
  93:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** */
  98:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
  99:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
 101:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #ifndef __DOXYGEN__
 102:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
 103:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #if defined(WDP3)
 104:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 105:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #else
 106:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 107:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #endif
 108:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
 109:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 110:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 111:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 112:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 113:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #else
 114:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 115:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #endif
 116:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
 117:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #if defined(WDTOE)
 118:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 119:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #else
 120:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 121:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #endif
 122:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
 123:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #endif	/* !__DOXYGEN__ */
 124:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
 125:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
 126:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** /**
 127:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 128:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 129:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 130:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 131:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 132:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 133:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
 134:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 135:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** */
 136:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
 137:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
 138:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 139:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
 140:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** /*
 141:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 142:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 143:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    registers to the CCP register
 144:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** ** At the same time,
 145:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 146:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 147:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 148:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 149:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 150:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****    sync is finished).
 151:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** */
 152:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 153:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** do { \
 154:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** uint8_t temp; \
 155:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 156:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 157:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 158:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 159:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 160:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 161:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 162:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 163:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 164:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 165:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 166:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 167:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 168:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 169:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 170:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 171:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 172:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     : "r0" \
 173:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** ); \
 174:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** } while(0)
 175:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
 176:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #define wdt_disable() \
 177:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 178:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 179:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 180:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 181:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 182:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 183:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     : \
 184:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 185:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 186:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 187:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 188:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 189:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     : "r0" \
 190:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** );
 191:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
 192:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 193:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
 194:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 195:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 196:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 197:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 198:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 199:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 200:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 201:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 202:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     : /* no outputs */  \
 203:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 204:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 205:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 206:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 207:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 208:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     : "r16" \
 209:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** )
 210:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
 211:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #define wdt_disable() \
 212:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** do { \
 213:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 214:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 215:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 216:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 217:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 218:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 219:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 220:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 221:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 222:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 223:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     : /*no output */ \
 224:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 225:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 226:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 227:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 228:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 229:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****     : "r16" \
 230:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** ); \
 231:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** }while(0)
 232:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
 233:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #elif defined(CCP)
 234:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
 235:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** static __inline__
 236:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 237:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 238:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** {
 239:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 240:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	{
 241:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 242:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 243:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 244:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 245:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 246:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 247:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 248:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			: /* no outputs */
 249:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 250:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 251:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 252:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 253:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 254:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			: "r0"
 255:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			);
 256:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	}
 257:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 258:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	{
 259:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 260:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 261:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 262:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 263:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 264:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 265:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 266:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			: /* no outputs */
 267:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 268:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 269:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 270:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 271:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 272:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			: "r0"
 273:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			);
 274:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	}
 275:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 276:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	{
 277:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 278:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 279:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 280:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 281:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 282:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 283:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 284:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			: /* no outputs */
 285:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 286:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 287:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 288:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 289:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 290:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			: "r0"
 291:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			);
 292:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	}
 293:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	else
 294:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****  	{
 295:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 296:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 297:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 298:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 299:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 300:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 301:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 302:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			: /* no outputs */
 303:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 304:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 305:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 306:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 307:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 308:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			: "r0"
 309:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 			);
 310:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	}
 311:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** }
 312:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
 313:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** static __inline__
 314:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 315:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** void wdt_disable (void)
 316:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** {
 317:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 318:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	{
 319:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 320:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 321:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 322:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 323:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 324:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 325:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 326:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 327:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 328:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 329:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				: /*no output */
 330:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 331:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 332:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 333:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 334:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 335:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				: "r0"
 336:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				);
 337:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	}
 338:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 339:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	{
 340:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 341:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 342:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 343:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 344:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 345:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 346:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 347:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 348:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 349:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 350:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				: /*no output */
 351:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 352:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 353:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 354:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 355:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 356:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				: "r0"
 357:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				);
 358:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	}
 359:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 360:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	{
 361:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 362:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 363:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 364:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 365:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 366:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 367:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 368:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 369:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 370:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 371:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				: /*no output */
 372:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 373:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 374:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 375:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 376:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 377:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				: "r0"
 378:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				);
 379:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	}
 380:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	else
 381:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	{
 382:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 383:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 384:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 385:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 386:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 387:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 388:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 389:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 390:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 391:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 392:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				: /*no output */
 393:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 394:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 395:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 396:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 397:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 398:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				: "r0"
 399:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				);
 400:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	}
 401:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** }
 402:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
 403:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** #else
 404:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
 405:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** static __inline__
 406:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 407:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 408:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** {
 409:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 410:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	{
 411:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 412:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 413:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 414:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 415:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 416:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 417:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 418:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				: /* no outputs */
 419:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 420:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 421:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 422:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 423:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				: "r0"
 424:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 		);
 425:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	}
 426:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	else
 427:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	{
 428:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 429:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 430:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 431:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 432:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"sts %0, %1" "\n\t"
 433:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 434:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"sts %0, %2" "\n \t"
 435:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				: /* no outputs */
 436:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				: "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 437:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 438:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 439:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 440:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				: "r0"
 441:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 		);
 442:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	}
 443:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** }
 444:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 
 445:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** static __inline__
 446:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 447:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** void wdt_disable (void)
 2120               		.loc 4 447 6 view .LVU605
 2121               	.LBE199:
 448:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** {
 449:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 2122               		.loc 4 449 2 view .LVU606
 2123               	.LBB201:
 2124               	.LBB200:
 450:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	{
 451:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 452:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 453:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__"    "\n\t"
 454:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"cli"                        "\n\t"
 455:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"wdr"                        "\n\t"
 456:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"in  %[TEMPREG],%[WDTREG]"   "\n\t"
 457:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"ori %[TEMPREG],%[WDCE_WDE]" "\n\t"
 458:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMPREG]"   "\n\t"
 459:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"out %[WDTREG],__zero_reg__" "\n\t"
 460:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__"   "\n\t"
 461:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				: [TEMPREG] "=d" (temp_reg)
 462:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				: [WDTREG]  "I"  (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 463:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				[WDCE_WDE]  "n"  ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE)))
 464:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 				: "r0"
 465:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 		);
 466:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	}
 467:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	else
 468:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 	{
 469:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 2125               		.loc 4 469 9 view .LVU607
 470:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 2126               		.loc 4 470 3 view .LVU608
 2127               	/* #APP */
 2128               	 ;  470 "/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/wdt.h" 1
 2129 0002 0FB6      		in __tmp_reg__,__SREG__
 2130 0004 F894      		cli
 2131 0006 A895      		wdr
 2132 0008 8091 6000 		lds r24,96
 2133 000c 8861      		ori r24,24
 2134 000e 8093 6000 		sts 96,r24
 2135 0012 1092 6000 		sts 96,__zero_reg__
 2136 0016 0FBE      		out __SREG__,__tmp_reg__
 2137               		
 2138               	 ;  0 "" 2
 2139               	/* #NOAPP */
 2140               	.LBE200:
 2141               	.LBE201:
 249:Caterina.c    ****     _delay_ms(10);    // allow time for caps to charge
 2142               		.loc 1 249 5 view .LVU609
 2143 0018 6A98      		cbi 0xd,2
 249:Caterina.c    ****     _delay_ms(10);    // allow time for caps to charge
 2144               		.loc 1 249 5 view .LVU610
 2145 001a 729A      		sbi 0xe,2
 249:Caterina.c    ****     _delay_ms(10);    // allow time for caps to charge
 2146               		.loc 1 249 20 view .LVU611
 250:Caterina.c    **** 
 2147               		.loc 1 250 5 view .LVU612
 2148               	.LVL118:
 2149               	.LBB202:
 2150               	.LBI202:
 166:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** {
 2151               		.loc 3 166 1 view .LVU613
 2152               	.LBB203:
 168:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 2153               		.loc 3 168 2 view .LVU614
 172:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 2154               		.loc 3 172 2 view .LVU615
 173:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 2155               		.loc 3 173 2 view .LVU616
 174:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 
 2156               		.loc 3 174 2 view .LVU617
 184:/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/util/delay.h **** 	#endif
 2157               		.loc 3 184 3 view .LVU618
 2158               		.loc 3 187 2 view .LVU619
 2159 001c 8FE1      		ldi r24,lo8(19999)
 2160 001e 9EE4      		ldi r25,hi8(19999)
 2161 0020 0197      	1:	sbiw r24,1
 2162 0022 01F4      		brne 1b
 2163 0024 00C0      		rjmp .
 2164 0026 0000      		nop
 2165               	.LVL119:
 2166               		.loc 3 187 2 is_stmt 0 view .LVU620
 2167               	.LBE203:
 2168               	.LBE202:
 252:Caterina.c    ****     {
 2169               		.loc 1 252 5 is_stmt 1 view .LVU621
 252:Caterina.c    ****     {
 2170               		.loc 1 252 8 is_stmt 0 view .LVU622
 2171 0028 629B      		sbis 0xc,2
 2172 002a 00C0      		rjmp .L150
 2173               	.LBB204:
 252:Caterina.c    ****     {
 2174               		.loc 1 252 27 is_stmt 1 discriminator 1 view .LVU623
 2175               	.LVL120:
 252:Caterina.c    ****     {
 2176               		.loc 1 252 27 discriminator 1 view .LVU624
 252:Caterina.c    ****     {
 2177               		.loc 1 252 27 discriminator 1 view .LVU625
 2178 002c F0E0      		ldi r31,0
 2179 002e E0E0      		ldi r30,0
 2180               	/* #APP */
 2181               	 ;  252 "Caterina.c" 1
 2182 0030 8591      		lpm r24, Z+
 2183 0032 9491      		lpm r25, Z
 2184               		
 2185               	 ;  0 "" 2
 2186               	.LVL121:
 252:Caterina.c    ****     {
 2187               		.loc 1 252 27 discriminator 1 view .LVU626
 2188               	/* #NOAPP */
 2189               	.LBE204:
 252:Caterina.c    ****     {
 2190               		.loc 1 252 23 is_stmt 0 discriminator 1 view .LVU627
 2191 0034 0196      		adiw r24,1
 2192 0036 01F4      		brne .L153
 2193               	.LVL122:
 2194               	.L150:
 257:Caterina.c    **** 
 2195               		.loc 1 257 9 is_stmt 1 view .LVU628
 2196 0038 0E94 0000 		call SetupHardware
 2197               	.LVL123:
 260:Caterina.c    **** 
 2198               		.loc 1 260 9 view .LVU629
 2199               	/* #APP */
 2200               	 ;  260 "Caterina.c" 1
 2201 003c 7894      		sei
 2202               	 ;  0 "" 2
 262:Caterina.c    ****             CDC_Task();
 2203               		.loc 1 262 9 view .LVU630
 2204               	/* #NOAPP */
 2205               	.L151:
 262:Caterina.c    ****             CDC_Task();
 2206               		.loc 1 262 14 view .LVU631
 2207 003e 629B      		sbis 0xc,2
 2208 0040 00C0      		rjmp .L152
 2209               	.L153:
 270:Caterina.c    **** 
 2210               		.loc 1 270 5 view .LVU632
 2211               	.LBB205:
 2212               	.LBI205:
 2213               		.file 5 "../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h"
   1:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** /*
   2:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****              LUFA Library
   3:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****      Copyright (C) Dean Camera, 2011.
   4:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 
   5:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****   dean [at] fourwalledcubicle [dot] com
   6:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****            www.lufa-lib.org
   7:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** */
   8:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 
   9:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** /*
  10:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 
  12:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****   Permission to use, copy, modify, distribute, and sell this
  13:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****   software and its documentation for any purpose is hereby granted
  14:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****   without fee, provided that the above copyright notice appear in
  15:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****   all copies and that both that the copyright notice and this
  16:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****   permission notice and warranty disclaimer appear in supporting
  17:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****   documentation, and that the name of the author not be used in
  18:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****   advertising or publicity pertaining to distribution of the
  19:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****   software without specific, written prior permission.
  20:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 
  21:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****   The author disclaim all warranties with regard to this
  22:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****   software, including all implied warranties of merchantability
  23:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****   and fitness.  In no event shall the author be liable for any
  24:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****   special, indirect or consequential damages or any damages
  25:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****   whatsoever resulting from loss of use, data or profits, whether
  26:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****   in an action of contract, negligence or other tortious action,
  27:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****   arising out of or in connection with the use or performance of
  28:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****   this software.
  29:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** */
  30:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 
  31:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** /** \file
  32:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****  *  \brief USB Controller definitions for the AVR8 microcontrollers.
  33:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****  *  \copydetails Group_USBManagement_AVR8
  34:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****  *
  35:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****  *  \note This file should not be included directly. It is automatically included as needed by the 
  36:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****  *        dispatch header located in LUFA/Drivers/USB/USB.h.
  37:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****  */
  38:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 
  39:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** /** \ingroup Group_USBManagement
  40:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****  *  \defgroup Group_USBManagement_AVR8 USB Interface Management (AVR8)
  41:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****  *  \brief USB Controller definitions for the AVR8 microcontrollers.
  42:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****  *
  43:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****  *  Functions, macros, variables, enums and types related to the setup and management of the USB in
  44:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****  *
  45:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****  *  @{
  46:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h ****  */
  47:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 
  48:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** #ifndef __USBCONTROLLER_AVR8_H__
  49:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** #define __USBCONTROLLER_AVR8_H__
  50:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 
  51:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 	/* Includes: */
  52:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 		#include "../../../../Common/Common.h"
  53:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 		#include "../USBMode.h"
  54:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 		#include "../Events.h"
  55:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 		#include "../USBTask.h"
  56:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 		#include "../USBInterrupt.h"
  57:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 
  58:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 		#if defined(USB_CAN_BE_HOST) || defined(__DOXYGEN__)
  59:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#include "../Host.h"
  60:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#include "../OTG.h"
  61:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#include "../Pipe.h"
  62:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#include "../HostStandardReq.h"
  63:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#include "../PipeStream.h"
  64:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 		#endif
  65:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 
  66:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 		#if defined(USB_CAN_BE_DEVICE) || defined(__DOXYGEN__)
  67:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#include "../Device.h"
  68:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#include "../Endpoint.h"
  69:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#include "../DeviceStandardReq.h"
  70:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#include "../EndpointStream.h"
  71:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 		#endif
  72:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 
  73:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 	/* Enable C linkage for C++ Compilers: */
  74:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 		#if defined(__cplusplus)
  75:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			extern "C" {
  76:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 		#endif
  77:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 
  78:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 	/* Preprocessor Checks and Defines: */
  79:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 		#if !defined(__INCLUDE_FROM_USB_DRIVER)
  80:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#error Do not include this file directly. Include LUFA/Drivers/USB/USB.h instead.
  81:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 		#endif
  82:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 
  83:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 		#if !defined(F_USB)
  84:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#error F_USB is not defined. You must define F_USB to the frequency of the unprescaled USB contr
  85:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 		#endif
  86:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 
  87:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 		#if (F_USB == 8000000)
  88:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#if (defined(__AVR_AT90USB82__) || defined(__AVR_AT90USB162__) || \
  89:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			     defined(__AVR_ATmega8U2__) || defined(__AVR_ATmega16U2__) || \
  90:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			     defined(__AVR_ATmega32U2__))
  91:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				#define USB_PLL_PSC                0
  92:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#elif (defined(__AVR_ATmega16U4__) || defined(__AVR_ATmega32U4__))
  93:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				#define USB_PLL_PSC                0
  94:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#elif (defined(__AVR_AT90USB646__)  || defined(__AVR_AT90USB1286__) || defined(__AVR_ATmega32U6_
  95:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				#define USB_PLL_PSC                ((1 << PLLP1) | (1 << PLLP0))
  96:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#elif (defined(__AVR_AT90USB647__)  || defined(__AVR_AT90USB1287__))
  97:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				#define USB_PLL_PSC                ((1 << PLLP1) | (1 << PLLP0))
  98:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#endif
  99:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 		#elif (F_USB == 16000000)
 100:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#if (defined(__AVR_AT90USB82__) || defined(__AVR_AT90USB162__) || \
 101:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			     defined(__AVR_ATmega8U2__) || defined(__AVR_ATmega16U2__) || \
 102:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			     defined(__AVR_ATmega32U2__))
 103:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				#define USB_PLL_PSC                (1 << PLLP0)
 104:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#elif (defined(__AVR_ATmega16U4__) || defined(__AVR_ATmega32U4__))
 105:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				#define USB_PLL_PSC                (1 << PINDIV)
 106:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#elif (defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB647__) || defined(__AVR_ATmega32U6__)
 107:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				#define USB_PLL_PSC                ((1 << PLLP2) | (1 << PLLP1))
 108:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#elif (defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB1287__))
 109:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				#define USB_PLL_PSC                ((1 << PLLP2) | (1 << PLLP0))
 110:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#endif
 111:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 		#endif
 112:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 
 113:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 		#if !defined(USB_PLL_PSC)
 114:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#error No PLL prescale value available for chosen F_USB value and AVR model.
 115:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 		#endif
 116:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 
 117:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 	/* Public Interface - May be used in end-application: */
 118:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 		/* Macros: */
 119:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			/** \name USB Controller Option Masks */
 120:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			//@{
 121:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			/** Regulator disable option mask for \ref USB_Init(). This indicates that the internal 3.3V USB
 122:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			 *  regulator should be disabled and the AVR's VCC level used for the data pads.
 123:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			 *
 124:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			 *  \note See USB AVR data sheet for more information on the internal pad regulator.
 125:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			 */
 126:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#define USB_OPT_REG_DISABLED               (1 << 1)
 127:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 
 128:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			/** Regulator enable option mask for \ref USB_Init(). This indicates that the internal 3.3V USB 
 129:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			 *  regulator should be enabled to regulate the data pin voltages from the VBUS level down to a 
 130:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			 *  the range allowable by the USB standard.
 131:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			 *
 132:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			 *  \note See USB AVR data sheet for more information on the internal pad regulator.
 133:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			 */
 134:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#define USB_OPT_REG_ENABLED                (0 << 1)
 135:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 
 136:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			/** Manual PLL control option mask for \ref USB_Init(). This indicates to the library that the u
 137:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			 *  will take full responsibility for controlling the AVR's PLL (used to generate the high frequ
 138:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			 *  that the USB controller requires) and ensuring that it is locked at the correct frequency fo
 139:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			 */
 140:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#define USB_OPT_MANUAL_PLL                 (1 << 2)
 141:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 
 142:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			/** Automatic PLL control option mask for \ref USB_Init(). This indicates to the library that th
 143:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			 *  take full responsibility for controlling the AVR's PLL (used to generate the high frequency 
 144:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			 *  that the USB controller requires) and ensuring that it is locked at the correct frequency fo
 145:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			 */
 146:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#define USB_OPT_AUTO_PLL                   (0 << 2)
 147:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			//@}
 148:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 
 149:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#if !defined(USB_STREAM_TIMEOUT_MS) || defined(__DOXYGEN__)
 150:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				/** Constant for the maximum software timeout period of the USB data stream transfer functions
 151:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				 *  (both control and standard) when in either device or host mode. If the next packet of a str
 152:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				 *  is not received or acknowledged within this time period, the stream function will fail.
 153:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				 *
 154:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				 *  This value may be overridden in the user project makefile as the value of the
 155:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				 *  \ref USB_STREAM_TIMEOUT_MS token, and passed to the compiler using the -D switch.
 156:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				 */
 157:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				#define USB_STREAM_TIMEOUT_MS       100
 158:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#endif
 159:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 
 160:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 		/* Inline Functions: */
 161:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR) || defin
 162:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				/** Determines if the VBUS line is currently high (i.e. the USB host is supplying power).
 163:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				 *
 164:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				 *  \note This function is not available on some AVR models which do not support hardware VBUS 
 165:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				 *
 166:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false
 167:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				 */
 168:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 169:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				static inline bool USB_VBUS_GetStatus(void)
 170:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				{
 171:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 					return ((USBSTA & (1 << VBUS)) ? true : false);
 172:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				}
 173:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			#endif
 174:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 
 175:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			/** Detaches the device from the USB bus. This has the effect of removing the device from any
 176:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			 *  attached host, ceasing USB communications. If no host is present, this prevents any host fro
 177:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			 *  enumerating the device once attached until \ref USB_Attach() is called.
 178:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			 */
 179:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			static inline void USB_Detach(void) ATTR_ALWAYS_INLINE;
 180:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			static inline void USB_Detach(void)
 2214               		.loc 5 180 23 view .LVU633
 2215               	.LBB206:
 181:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 			{
 182:../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/USBController_AVR8.h **** 				UDCON  |=  (1 << DETACH);
 2216               		.loc 5 182 5 view .LVU634
 2217               		.loc 5 182 12 is_stmt 0 view .LVU635
 2218 0042 8091 E000 		lds r24,224
 2219 0046 8160      		ori r24,lo8(1)
 2220 0048 8093 E000 		sts 224,r24
 2221               	.LBE206:
 2222               	.LBE205:
 272:Caterina.c    **** 
 2223               		.loc 1 272 5 is_stmt 1 view .LVU636
 2224 004c 0E94 0000 		call SetupCurrentLimit
 2225               	.LVL124:
 280:Caterina.c    **** }
 2226               		.loc 1 280 5 view .LVU637
 2227 0050 0E94 0000 		call StartSketch
 2228               	.LVL125:
 281:Caterina.c    **** 
 2229               		.loc 1 281 1 is_stmt 0 view .LVU638
 2230 0054 90E0      		ldi r25,0
 2231 0056 80E0      		ldi r24,0
 2232               	/* epilogue start */
 2233 0058 0895      		ret
 2234               	.L152:
 263:Caterina.c    ****             USB_USBTask();
 2235               		.loc 1 263 13 is_stmt 1 view .LVU639
 2236 005a 0E94 0000 		call CDC_Task
 2237               	.LVL126:
 264:Caterina.c    **** 
 2238               		.loc 1 264 13 view .LVU640
 2239 005e 0E94 0000 		call USB_USBTask
 2240               	.LVL127:
 266:Caterina.c    ****         }
 2241               		.loc 1 266 13 view .LVU641
 2242 0062 0E94 0000 		call LEDPulse
 2243               	.LVL128:
 2244 0066 00C0      		rjmp .L151
 2245               		.cfi_endproc
 2246               	.LFE108:
 2248               		.comm	LLEDPulse,2,1
 2249               	.global	Timeout
 2250               		.section .bss
 2253               	Timeout:
 2254 0000 0000      		.zero	2
 2255               	.global	RxLEDPulse
 2258               	RxLEDPulse:
 2259 0002 0000      		.zero	2
 2260               	.global	TxLEDPulse
 2263               	TxLEDPulse:
 2264 0004 0000      		.zero	2
 2265               		.local	CurrAddress
 2266               		.comm	CurrAddress,4,1
 2267               		.data
 2270               	LineEncoding:
 2271 0000 00        		.byte	0
 2272 0001 00        		.byte	0
 2273 0002 00        		.byte	0
 2274 0003 00        		.byte	0
 2275 0004 00        		.byte	0
 2276 0005 00        		.byte	0
 2277 0006 08        		.byte	8
 2278               		.text
 2279               	.Letext0:
 2280               		.file 6 "/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/stdint.h"
 2281               		.file 7 "../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../StdRequestType.h"
 2282               		.file 8 "../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../DeviceStandardReq.h"
 2283               		.file 9 "../../LUFA-111009/LUFA/Drivers/USB/Core/USBTask.h"
 2284               		.file 10 "../../LUFA-111009/LUFA/Drivers/USB/Core/HostStandardReq.h"
 2285               		.file 11 "../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../Device.h"
 2286               		.file 12 "../../LUFA-111009/LUFA/Drivers/USB/Class/Device/../Common/CDC.h"
 2287               		.file 13 "/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/stdio.h"
 2288               		.file 14 "/usr/local/Cellar/avr-gcc/9.2.0_1/avr/include/avr/eeprom.h"
 2289               		.file 15 "../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../AVR8/EndpointStream_AVR8.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Caterina.c
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:4      *ABS*:000000000000003f __SREG__
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:12     .text.FetchNextCommandByte:0000000000000000 FetchNextCommandByte
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:104    .text.WriteNextResponseByte:0000000000000000 WriteNextResponseByte
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:2263   .bss:0000000000000004 TxLEDPulse
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:209    .text.StartSketch:0000000000000000 StartSketch
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:263    .text.TWIInit:0000000000000000 TWIInit
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:291    .text.TWIStart:0000000000000000 TWIStart
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:321    .text.TWIStop:0000000000000000 TWIStop
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:342    .text.TWIWrite:0000000000000000 TWIWrite
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:379    .text.SetupCurrentLimit:0000000000000000 SetupCurrentLimit
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:418    .text.ReadBatteryVoltage:0000000000000000 ReadBatteryVoltage
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:498    .text.AlertFatalError:0000000000000000 AlertFatalError
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:575    .text.LEDPulse:0000000000000000 LEDPulse
                            *COM*:0000000000000002 LLEDPulse
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:628    .text.SetupHardware:0000000000000000 SetupHardware
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:686    .text.__vector_17:0000000000000000 __vector_17
                            *ABS*:0000000000000003 __gcc_isr.n_pushed.001
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:2258   .bss:0000000000000002 RxLEDPulse
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:2253   .bss:0000000000000000 Timeout
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:797    .text.EVENT_USB_Device_ConfigurationChanged:0000000000000000 EVENT_USB_Device_ConfigurationChanged
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:868    .text.EVENT_USB_Device_ControlRequest:0000000000000000 EVENT_USB_Device_ControlRequest
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:2270   .data:0000000000000000 LineEncoding
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:982    .text.CDC_Task:0000000000000000 CDC_Task
                             .bss:0000000000000006 CurrAddress
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:2105   .text.startup.main:0000000000000000 main
/var/folders/21/48xmffd55532bzn9lrp15kkc0000gn/T//ccLa5AF6.s:977    .rodata.str1.1:0000000000000000 .LC0

UNDEFINED SYMBOLS
USB_Init
Endpoint_ConfigureEndpoint_Prv
USB_ControlRequest
Endpoint_Write_Control_Stream_LE
Endpoint_Read_Control_Stream_LE
eeprom_read_byte
eeprom_write_byte
USB_USBTask
__do_copy_data
__do_clear_bss
