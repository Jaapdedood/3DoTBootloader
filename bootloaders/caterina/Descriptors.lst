   1               		.file	"Descriptors.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.CALLBACK_USB_GetDescriptor,"ax",@progbits
  11               	.global	CALLBACK_USB_GetDescriptor
  13               	CALLBACK_USB_GetDescriptor:
  14               	.LFB94:
  15               		.file 1 "Descriptors.c"
   1:Descriptors.c **** /*
   2:Descriptors.c ****              LUFA Library
   3:Descriptors.c ****      Copyright (C) Dean Camera, 2011.
   4:Descriptors.c **** 
   5:Descriptors.c ****   dean [at] fourwalledcubicle [dot] com
   6:Descriptors.c ****            www.lufa-lib.org
   7:Descriptors.c **** */
   8:Descriptors.c **** 
   9:Descriptors.c **** /*
  10:Descriptors.c ****   Copyright 2011  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:Descriptors.c **** 
  12:Descriptors.c ****   Permission to use, copy, modify, distribute, and sell this
  13:Descriptors.c ****   software and its documentation for any purpose is hereby granted
  14:Descriptors.c ****   without fee, provided that the above copyright notice appear in
  15:Descriptors.c ****   all copies and that both that the copyright notice and this
  16:Descriptors.c ****   permission notice and warranty disclaimer appear in supporting
  17:Descriptors.c ****   documentation, and that the name of the author not be used in
  18:Descriptors.c ****   advertising or publicity pertaining to distribution of the
  19:Descriptors.c ****   software without specific, written prior permission.
  20:Descriptors.c **** 
  21:Descriptors.c ****   The author disclaim all warranties with regard to this
  22:Descriptors.c ****   software, including all implied warranties of merchantability
  23:Descriptors.c ****   and fitness.  In no event shall the author be liable for any
  24:Descriptors.c ****   special, indirect or consequential damages or any damages
  25:Descriptors.c ****   whatsoever resulting from loss of use, data or profits, whether
  26:Descriptors.c ****   in an action of contract, negligence or other tortious action,
  27:Descriptors.c ****   arising out of or in connection with the use or performance of
  28:Descriptors.c ****   this software.
  29:Descriptors.c **** */
  30:Descriptors.c **** 
  31:Descriptors.c **** /*
  32:Descriptors.c **** Copyright (c) 2014 Pololu Corporation.  For more information, see
  33:Descriptors.c **** 
  34:Descriptors.c **** http://www.pololu.com/
  35:Descriptors.c **** http://forum.pololu.com/
  36:Descriptors.c **** 
  37:Descriptors.c **** Permission is hereby granted, free of charge, to any person
  38:Descriptors.c **** obtaining a copy of this software and associated documentation
  39:Descriptors.c **** files (the "Software"), to deal in the Software without
  40:Descriptors.c **** restriction, including without limitation the rights to use,
  41:Descriptors.c **** copy, modify, merge, publish, distribute, sublicense, and/or sell
  42:Descriptors.c **** copies of the Software, and to permit persons to whom the
  43:Descriptors.c **** Software is furnished to do so, subject to the following
  44:Descriptors.c **** conditions:
  45:Descriptors.c **** 
  46:Descriptors.c **** The above copyright notice and this permission notice shall be
  47:Descriptors.c **** included in all copies or substantial portions of the Software.
  48:Descriptors.c **** 
  49:Descriptors.c **** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  50:Descriptors.c **** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
  51:Descriptors.c **** OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  52:Descriptors.c **** NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  53:Descriptors.c **** HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
  54:Descriptors.c **** WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
  55:Descriptors.c **** FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
  56:Descriptors.c **** OTHER DEALINGS IN THE SOFTWARE.
  57:Descriptors.c **** */
  58:Descriptors.c **** 
  59:Descriptors.c **** /*
  60:Descriptors.c **** This file was modified by Pololu from the original Arduino Caterina
  61:Descriptors.c **** bootloader to support the A-Star 32U4.
  62:Descriptors.c **** */
  63:Descriptors.c **** 
  64:Descriptors.c **** /** \file
  65:Descriptors.c ****  *
  66:Descriptors.c ****  *  USB Device Descriptors, for library use when in USB device mode. Descriptors are special
  67:Descriptors.c ****  *  computer-readable structures which the host requests upon device enumeration, to determine
  68:Descriptors.c ****  *  the device's capabilities and functions.
  69:Descriptors.c ****  */
  70:Descriptors.c **** 
  71:Descriptors.c **** #include "Descriptors.h"
  72:Descriptors.c **** 
  73:Descriptors.c **** /** Device descriptor structure. This descriptor, located in SRAM memory, describes the overall
  74:Descriptors.c ****  *  device characteristics, including the supported USB version, control endpoint size and the
  75:Descriptors.c ****  *  number of device configurations. The descriptor is read out by the USB host when the enumeratio
  76:Descriptors.c ****  *  process begins.
  77:Descriptors.c ****  */
  78:Descriptors.c **** const USB_Descriptor_Device_t DeviceDescriptor =
  79:Descriptors.c **** {
  80:Descriptors.c **** 	.Header                 = {.Size = sizeof(USB_Descriptor_Device_t), .Type = DTYPE_Device},
  81:Descriptors.c **** 
  82:Descriptors.c **** 	.USBSpecification       = VERSION_BCD(01.10),
  83:Descriptors.c **** 	.Class                  = CDC_CSCP_CDCClass,
  84:Descriptors.c **** 	.SubClass               = CDC_CSCP_NoSpecificSubclass,
  85:Descriptors.c **** 	.Protocol               = CDC_CSCP_NoSpecificProtocol,
  86:Descriptors.c **** 
  87:Descriptors.c **** 	.Endpoint0Size          = FIXED_CONTROL_ENDPOINT_SIZE,
  88:Descriptors.c **** 
  89:Descriptors.c **** 	.VendorID               = DEVICE_VID,
  90:Descriptors.c **** 	.ProductID              = DEVICE_PID,
  91:Descriptors.c **** 	.ReleaseNumber          = VERSION_BCD(00.01),
  92:Descriptors.c **** 
  93:Descriptors.c **** 	.ManufacturerStrIndex   = 0x02,
  94:Descriptors.c **** 	.ProductStrIndex        = 0x01,
  95:Descriptors.c **** 	.SerialNumStrIndex      = NO_DESCRIPTOR,
  96:Descriptors.c **** 
  97:Descriptors.c **** 	.NumberOfConfigurations = FIXED_NUM_CONFIGURATIONS
  98:Descriptors.c **** };
  99:Descriptors.c **** 
 100:Descriptors.c **** /** Configuration descriptor structure. This descriptor, located in SRAM memory, describes the usag
 101:Descriptors.c ****  *  of the device in one of its supported configurations, including information about any device in
 102:Descriptors.c ****  *  and endpoints. The descriptor is read out by the USB host during the enumeration process when s
 103:Descriptors.c ****  *  a configuration so that the host may correctly communicate with the USB device.
 104:Descriptors.c ****  */
 105:Descriptors.c **** const USB_Descriptor_Configuration_t ConfigurationDescriptor =
 106:Descriptors.c **** {
 107:Descriptors.c **** 	.Config =
 108:Descriptors.c **** 		{
 109:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Configuration_Header_t), .Type = DTYPE_
 110:Descriptors.c **** 
 111:Descriptors.c **** 			.TotalConfigurationSize = sizeof(USB_Descriptor_Configuration_t),
 112:Descriptors.c **** 			.TotalInterfaces        = 2,
 113:Descriptors.c **** 
 114:Descriptors.c **** 			.ConfigurationNumber    = 1,
 115:Descriptors.c **** 			.ConfigurationStrIndex  = NO_DESCRIPTOR,
 116:Descriptors.c **** 
 117:Descriptors.c **** 			.ConfigAttributes       = USB_CONFIG_ATTR_BUSPOWERED,
 118:Descriptors.c **** 
 119:Descriptors.c **** 			.MaxPowerConsumption    = USB_CONFIG_POWER_MA(100)
 120:Descriptors.c **** 		},
 121:Descriptors.c **** 
 122:Descriptors.c **** 	.CDC_CCI_Interface =
 123:Descriptors.c **** 		{
 124:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface},
 125:Descriptors.c **** 
 126:Descriptors.c **** 			.InterfaceNumber        = 0,
 127:Descriptors.c **** 			.AlternateSetting       = 0,
 128:Descriptors.c **** 
 129:Descriptors.c **** 			.TotalEndpoints         = 1,
 130:Descriptors.c **** 
 131:Descriptors.c **** 			.Class                  = CDC_CSCP_CDCClass,
 132:Descriptors.c **** 			.SubClass               = CDC_CSCP_ACMSubclass,
 133:Descriptors.c **** 			.Protocol               = CDC_CSCP_ATCommandProtocol,
 134:Descriptors.c **** 
 135:Descriptors.c **** 			.InterfaceStrIndex      = NO_DESCRIPTOR
 136:Descriptors.c **** 		},
 137:Descriptors.c **** 
 138:Descriptors.c **** 	.CDC_Functional_Header =
 139:Descriptors.c **** 		{
 140:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_CDC_Descriptor_FunctionalHeader_t), .Type = DTYPE_
 141:Descriptors.c **** 			.Subtype                = 0x00,
 142:Descriptors.c **** 
 143:Descriptors.c **** 			.CDCSpecification       = VERSION_BCD(01.10),
 144:Descriptors.c **** 		},
 145:Descriptors.c **** 
 146:Descriptors.c **** 	.CDC_Functional_ACM =
 147:Descriptors.c **** 		{
 148:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_CDC_Descriptor_FunctionalACM_t), .Type = DTYPE_CSI
 149:Descriptors.c **** 			.Subtype                = 0x02,
 150:Descriptors.c **** 
 151:Descriptors.c **** 			.Capabilities           = 0x04,
 152:Descriptors.c **** 		},
 153:Descriptors.c **** 
 154:Descriptors.c **** 	.CDC_Functional_Union =
 155:Descriptors.c **** 		{
 156:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_CDC_Descriptor_FunctionalUnion_t), .Type = DTYPE_C
 157:Descriptors.c **** 			.Subtype                = 0x06,
 158:Descriptors.c **** 
 159:Descriptors.c **** 			.MasterInterfaceNumber  = 0,
 160:Descriptors.c **** 			.SlaveInterfaceNumber   = 1,
 161:Descriptors.c **** 		},
 162:Descriptors.c **** 
 163:Descriptors.c **** 	.CDC_NotificationEndpoint =
 164:Descriptors.c **** 		{
 165:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 166:Descriptors.c **** 
 167:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_IN | CDC_NOTIFICATION_EPNUM),
 168:Descriptors.c **** 			.Attributes             = (EP_TYPE_INTERRUPT | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 169:Descriptors.c **** 			.EndpointSize           = CDC_NOTIFICATION_EPSIZE,
 170:Descriptors.c **** 			.PollingIntervalMS      = 0xFF
 171:Descriptors.c **** 		},
 172:Descriptors.c **** 
 173:Descriptors.c **** 	.CDC_DCI_Interface =
 174:Descriptors.c **** 		{
 175:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Interface_t), .Type = DTYPE_Interface},
 176:Descriptors.c **** 
 177:Descriptors.c **** 			.InterfaceNumber        = 1,
 178:Descriptors.c **** 			.AlternateSetting       = 0,
 179:Descriptors.c **** 
 180:Descriptors.c **** 			.TotalEndpoints         = 2,
 181:Descriptors.c **** 
 182:Descriptors.c **** 			.Class                  = CDC_CSCP_CDCDataClass,
 183:Descriptors.c **** 			.SubClass               = CDC_CSCP_NoDataSubclass,
 184:Descriptors.c **** 			.Protocol               = CDC_CSCP_NoDataProtocol,
 185:Descriptors.c **** 
 186:Descriptors.c **** 			.InterfaceStrIndex      = NO_DESCRIPTOR
 187:Descriptors.c **** 		},
 188:Descriptors.c **** 
 189:Descriptors.c **** 	.CDC_DataOutEndpoint =
 190:Descriptors.c **** 		{
 191:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 192:Descriptors.c **** 
 193:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_OUT | CDC_RX_EPNUM),
 194:Descriptors.c **** 			.Attributes             = (EP_TYPE_BULK | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 195:Descriptors.c **** 			.EndpointSize           = CDC_TXRX_EPSIZE,
 196:Descriptors.c **** 			.PollingIntervalMS      = 0x01
 197:Descriptors.c **** 		},
 198:Descriptors.c **** 
 199:Descriptors.c **** 	.CDC_DataInEndpoint =
 200:Descriptors.c **** 		{
 201:Descriptors.c **** 			.Header                 = {.Size = sizeof(USB_Descriptor_Endpoint_t), .Type = DTYPE_Endpoint},
 202:Descriptors.c **** 
 203:Descriptors.c **** 			.EndpointAddress        = (ENDPOINT_DIR_IN | CDC_TX_EPNUM),
 204:Descriptors.c **** 			.Attributes             = (EP_TYPE_BULK | ENDPOINT_ATTR_NO_SYNC | ENDPOINT_USAGE_DATA),
 205:Descriptors.c **** 			.EndpointSize           = CDC_TXRX_EPSIZE,
 206:Descriptors.c **** 			.PollingIntervalMS      = 0x01
 207:Descriptors.c **** 		}
 208:Descriptors.c **** };
 209:Descriptors.c **** 
 210:Descriptors.c **** /** Language descriptor structure. This descriptor, located in SRAM memory, is returned when the ho
 211:Descriptors.c ****  *  the string descriptor with index 0 (the first index). It is actually an array of 16-bit integer
 212:Descriptors.c ****  *  via the language ID table available at USB.org what languages the device supports for its strin
 213:Descriptors.c ****  */
 214:Descriptors.c **** const USB_Descriptor_String_t LanguageString =
 215:Descriptors.c **** {
 216:Descriptors.c **** 	.Header                 = {.Size = USB_STRING_LEN(1), .Type = DTYPE_String},
 217:Descriptors.c **** 
 218:Descriptors.c **** 	.UnicodeString          = {LANGUAGE_ID_ENG}
 219:Descriptors.c **** };
 220:Descriptors.c **** 
 221:Descriptors.c **** /** Product descriptor string. This is a Unicode string containing the product's details in human r
 222:Descriptors.c ****  *  and is read out upon request by the host when the appropriate string ID is requested, listed in
 223:Descriptors.c ****  *  Descriptor.
 224:Descriptors.c ****  */
 225:Descriptors.c **** const USB_Descriptor_String_t ProductString =
 226:Descriptors.c **** {
 227:Descriptors.c **** 	#if DEVICE_VID == 0x1FFB && DEVICE_PID == 0x0101
 228:Descriptors.c **** 	.Header        = {.Size = USB_STRING_LEN(29), .Type = DTYPE_String},
 229:Descriptors.c **** 	.UnicodeString = L"Pololu A-Star 32U4 Bootloader"
 230:Descriptors.c **** 	#else
 231:Descriptors.c **** 	.Header        = {.Size = USB_STRING_LEN(13), .Type = DTYPE_String},
 232:Descriptors.c **** 	.UnicodeString = L"USB I/O board"
 233:Descriptors.c **** 	#endif
 234:Descriptors.c **** };
 235:Descriptors.c **** 
 236:Descriptors.c **** const USB_Descriptor_String_t ManufNameString = 
 237:Descriptors.c **** {
 238:Descriptors.c **** 	#if DEVICE_VID == 0x1FFB
 239:Descriptors.c **** 	.Header        = {.Size = USB_STRING_LEN(18), .Type = DTYPE_String},
 240:Descriptors.c **** 	.UnicodeString = L"Pololu Corporation"
 241:Descriptors.c **** 	#else
 242:Descriptors.c **** 	.Header        = {.Size = USB_STRING_LEN(7), .Type = DTYPE_String},
 243:Descriptors.c **** 	.UnicodeString = L"Unknown"
 244:Descriptors.c **** 	#endif
 245:Descriptors.c **** };
 246:Descriptors.c **** 
 247:Descriptors.c **** /** This function is called by the library when in device mode, and must be overridden (see LUFA li
 248:Descriptors.c ****  *  documentation) by the application code so that the address and size of a requested descriptor c
 249:Descriptors.c ****  *  to the USB library. When the device receives a Get Descriptor request on the control endpoint, 
 250:Descriptors.c ****  *  is called so that the descriptor details can be passed back and the appropriate descriptor sent
 251:Descriptors.c ****  *  USB host.
 252:Descriptors.c ****  */
 253:Descriptors.c **** uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
 254:Descriptors.c ****                                     const uint8_t wIndex,
 255:Descriptors.c ****                                     const void** const DescriptorAddress)
 256:Descriptors.c **** {
  16               		.loc 1 256 0
  17               		.cfi_startproc
  18               	.LVL0:
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
 257:Descriptors.c **** 	const uint8_t  DescriptorType   = (wValue >> 8);
  23               		.loc 1 257 0
  24 0000 292F      		mov r18,r25
  25 0002 30E0      		ldi r19,0
 258:Descriptors.c **** 	const uint8_t  DescriptorNumber = (wValue & 0xFF);
 259:Descriptors.c **** 
 260:Descriptors.c **** 	const void* Address = NULL;
 261:Descriptors.c **** 	uint16_t    Size    = NO_DESCRIPTOR;
 262:Descriptors.c **** 
 263:Descriptors.c **** 	switch (DescriptorType)
  26               		.loc 1 263 0
  27 0004 2230      		cpi r18,2
  28 0006 3105      		cpc r19,__zero_reg__
  29 0008 01F0      		breq .L3
  30 000a 2330      		cpi r18,3
  31 000c 3105      		cpc r19,__zero_reg__
  32 000e 01F0      		breq .L4
  33 0010 2130      		cpi r18,1
  34 0012 3105      		cpc r19,__zero_reg__
  35 0014 01F4      		brne .L9
 264:Descriptors.c **** 	{
 265:Descriptors.c **** 		case DTYPE_Device:
 266:Descriptors.c **** 			Address = &DeviceDescriptor;
 267:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
  36               		.loc 1 267 0
  37 0016 82E1      		ldi r24,lo8(18)
  38 0018 90E0      		ldi r25,0
  39               	.LVL1:
 266:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Device_t);
  40               		.loc 1 266 0
  41 001a 20E0      		ldi r18,lo8(DeviceDescriptor)
  42 001c 30E0      		ldi r19,hi8(DeviceDescriptor)
  43 001e 00C0      		rjmp .L2
  44               	.LVL2:
  45               	.L3:
 268:Descriptors.c **** 			break;
 269:Descriptors.c **** 		case DTYPE_Configuration:
 270:Descriptors.c **** 			Address = &ConfigurationDescriptor;
 271:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  46               		.loc 1 271 0
  47 0020 8EE3      		ldi r24,lo8(62)
  48 0022 90E0      		ldi r25,0
  49               	.LVL3:
 270:Descriptors.c **** 			Size    = sizeof(USB_Descriptor_Configuration_t);
  50               		.loc 1 270 0
  51 0024 20E0      		ldi r18,lo8(ConfigurationDescriptor)
  52 0026 30E0      		ldi r19,hi8(ConfigurationDescriptor)
  53               	.LVL4:
 272:Descriptors.c **** 			break;
  54               		.loc 1 272 0
  55 0028 00C0      		rjmp .L2
  56               	.LVL5:
  57               	.L4:
 273:Descriptors.c **** 		case DTYPE_String:
 274:Descriptors.c **** 			if (!(DescriptorNumber))
  58               		.loc 1 274 0
  59 002a 8823      		tst r24
  60 002c 01F0      		breq .L7
 275:Descriptors.c **** 			{
 276:Descriptors.c **** 				Address = &LanguageString;
 277:Descriptors.c **** 				Size    = LanguageString.Header.Size;
 278:Descriptors.c **** 			}
 279:Descriptors.c **** 			else if (DescriptorNumber == DeviceDescriptor.ProductStrIndex) 
  61               		.loc 1 279 0
  62 002e 8130      		cpi r24,lo8(1)
  63 0030 01F0      		breq .L8
 280:Descriptors.c **** 			{
 281:Descriptors.c **** 				Address = &ProductString;
 282:Descriptors.c **** 				Size    = ProductString.Header.Size;
 283:Descriptors.c **** 			} else if (DescriptorNumber == DeviceDescriptor.ManufacturerStrIndex)
  64               		.loc 1 283 0
  65 0032 8230      		cpi r24,lo8(2)
  66 0034 01F4      		brne .L9
 284:Descriptors.c **** 			{
 285:Descriptors.c **** 				Address = &ManufNameString;
 286:Descriptors.c **** 				Size	= ManufNameString.Header.Size;
  67               		.loc 1 286 0
  68 0036 80E1      		ldi r24,lo8(16)
  69 0038 90E0      		ldi r25,0
  70               	.LVL6:
 285:Descriptors.c **** 				Size	= ManufNameString.Header.Size;
  71               		.loc 1 285 0
  72 003a 20E0      		ldi r18,lo8(ManufNameString)
  73 003c 30E0      		ldi r19,hi8(ManufNameString)
  74               	.LVL7:
  75 003e 00C0      		rjmp .L2
  76               	.LVL8:
  77               	.L7:
 277:Descriptors.c **** 			}
  78               		.loc 1 277 0
  79 0040 84E0      		ldi r24,lo8(4)
  80 0042 90E0      		ldi r25,0
  81               	.LVL9:
 276:Descriptors.c **** 				Size    = LanguageString.Header.Size;
  82               		.loc 1 276 0
  83 0044 20E0      		ldi r18,lo8(LanguageString)
  84 0046 30E0      		ldi r19,hi8(LanguageString)
  85               	.LVL10:
  86 0048 00C0      		rjmp .L2
  87               	.LVL11:
  88               	.L8:
 282:Descriptors.c **** 			} else if (DescriptorNumber == DeviceDescriptor.ManufacturerStrIndex)
  89               		.loc 1 282 0
  90 004a 8CE1      		ldi r24,lo8(28)
  91 004c 90E0      		ldi r25,0
  92               	.LVL12:
 281:Descriptors.c **** 				Size    = ProductString.Header.Size;
  93               		.loc 1 281 0
  94 004e 20E0      		ldi r18,lo8(ProductString)
  95 0050 30E0      		ldi r19,hi8(ProductString)
  96               	.LVL13:
  97 0052 00C0      		rjmp .L2
  98               	.LVL14:
  99               	.L9:
 261:Descriptors.c **** 
 100               		.loc 1 261 0
 101 0054 80E0      		ldi r24,0
 102 0056 90E0      		ldi r25,0
 103               	.LVL15:
 260:Descriptors.c **** 	uint16_t    Size    = NO_DESCRIPTOR;
 104               		.loc 1 260 0
 105 0058 20E0      		ldi r18,0
 106 005a 30E0      		ldi r19,0
 107               	.LVL16:
 108               	.L2:
 287:Descriptors.c **** 			}
 288:Descriptors.c **** 
 289:Descriptors.c **** 			break;
 290:Descriptors.c **** 	}
 291:Descriptors.c **** 
 292:Descriptors.c **** 	*DescriptorAddress = Address;
 109               		.loc 1 292 0
 110 005c FA01      		movw r30,r20
 111 005e 3183      		std Z+1,r19
 112 0060 2083      		st Z,r18
 293:Descriptors.c **** 	return Size;
 294:Descriptors.c **** }
 113               		.loc 1 294 0
 114 0062 0895      		ret
 115               		.cfi_endproc
 116               	.LFE94:
 118               	.global	ManufNameString
 119               		.section	.rodata
 122               	ManufNameString:
 123 0000 10        		.byte	16
 124 0001 03        		.byte	3
 125 0002 5500      		.string	"U"
 126 0004 6E00      		.string	"n"
 127 0006 6B00      		.string	"k"
 128 0008 6E00      		.string	"n"
 129 000a 6F00      		.string	"o"
 130 000c 7700      		.string	"w"
 131 000e 6E00      		.string	"n"
 132 0010 00        		.string	""
 133 0011 00        		.string	""
 134               	.global	ProductString
 137               	ProductString:
 138 0012 1C        		.byte	28
 139 0013 03        		.byte	3
 140 0014 5500      		.string	"U"
 141 0016 5300      		.string	"S"
 142 0018 4200      		.string	"B"
 143 001a 2000      		.string	" "
 144 001c 4900      		.string	"I"
 145 001e 2F00      		.string	"/"
 146 0020 4F00      		.string	"O"
 147 0022 2000      		.string	" "
 148 0024 6200      		.string	"b"
 149 0026 6F00      		.string	"o"
 150 0028 6100      		.string	"a"
 151 002a 7200      		.string	"r"
 152 002c 6400      		.string	"d"
 153 002e 00        		.string	""
 154 002f 00        		.string	""
 155               	.global	LanguageString
 158               	LanguageString:
 159 0030 04        		.byte	4
 160 0031 03        		.byte	3
 161 0032 0904      		.word	1033
 162               	.global	ConfigurationDescriptor
 165               	ConfigurationDescriptor:
 166 0034 09        		.byte	9
 167 0035 02        		.byte	2
 168 0036 3E00      		.word	62
 169 0038 02        		.byte	2
 170 0039 01        		.byte	1
 171 003a 00        		.byte	0
 172 003b 80        		.byte	-128
 173 003c 32        		.byte	50
 174 003d 09        		.byte	9
 175 003e 04        		.byte	4
 176 003f 00        		.byte	0
 177 0040 00        		.byte	0
 178 0041 01        		.byte	1
 179 0042 02        		.byte	2
 180 0043 02        		.byte	2
 181 0044 01        		.byte	1
 182 0045 00        		.byte	0
 183 0046 05        		.byte	5
 184 0047 24        		.byte	36
 185 0048 00        		.byte	0
 186 0049 1001      		.word	272
 187 004b 04        		.byte	4
 188 004c 24        		.byte	36
 189 004d 02        		.byte	2
 190 004e 04        		.byte	4
 191 004f 05        		.byte	5
 192 0050 24        		.byte	36
 193 0051 06        		.byte	6
 194 0052 00        		.byte	0
 195 0053 01        		.byte	1
 196 0054 07        		.byte	7
 197 0055 05        		.byte	5
 198 0056 82        		.byte	-126
 199 0057 03        		.byte	3
 200 0058 0800      		.word	8
 201 005a FF        		.byte	-1
 202 005b 09        		.byte	9
 203 005c 04        		.byte	4
 204 005d 01        		.byte	1
 205 005e 00        		.byte	0
 206 005f 02        		.byte	2
 207 0060 0A        		.byte	10
 208 0061 00        		.byte	0
 209 0062 00        		.byte	0
 210 0063 00        		.byte	0
 211 0064 07        		.byte	7
 212 0065 05        		.byte	5
 213 0066 04        		.byte	4
 214 0067 02        		.byte	2
 215 0068 1000      		.word	16
 216 006a 01        		.byte	1
 217 006b 07        		.byte	7
 218 006c 05        		.byte	5
 219 006d 83        		.byte	-125
 220 006e 02        		.byte	2
 221 006f 1000      		.word	16
 222 0071 01        		.byte	1
 223               	.global	DeviceDescriptor
 226               	DeviceDescriptor:
 227 0072 12        		.byte	18
 228 0073 01        		.byte	1
 229 0074 1001      		.word	272
 230 0076 02        		.byte	2
 231 0077 00        		.byte	0
 232 0078 00        		.byte	0
 233 0079 08        		.byte	8
 234 007a 4123      		.word	9025
 235 007c 3600      		.word	54
 236 007e 0100      		.word	1
 237 0080 02        		.byte	2
 238 0081 01        		.byte	1
 239 0082 00        		.byte	0
 240 0083 01        		.byte	1
 241               		.text
 242               	.Letext0:
 243               		.file 2 "/usr/lib/avr/include/stdint.h"
 244               		.file 3 "/usr/lib/gcc/avr/4.9.2/include/stddef.h"
 245               		.file 4 "../../LUFA-111009/LUFA/Drivers/USB/Core/AVR8/../StdDescriptors.h"
 246               		.file 5 "../../LUFA-111009/LUFA/Drivers/USB/Class/Device/../Common/CDC.h"
 247               		.file 6 "Descriptors.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Descriptors.c
     /tmp/ccPdwjeH.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccPdwjeH.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccPdwjeH.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccPdwjeH.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccPdwjeH.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccPdwjeH.s:13     .text.CALLBACK_USB_GetDescriptor:0000000000000000 CALLBACK_USB_GetDescriptor
     /tmp/ccPdwjeH.s:226    .rodata:0000000000000072 DeviceDescriptor
     /tmp/ccPdwjeH.s:165    .rodata:0000000000000034 ConfigurationDescriptor
     /tmp/ccPdwjeH.s:122    .rodata:0000000000000000 ManufNameString
     /tmp/ccPdwjeH.s:158    .rodata:0000000000000030 LanguageString
     /tmp/ccPdwjeH.s:137    .rodata:0000000000000012 ProductString

UNDEFINED SYMBOLS
__do_copy_data
